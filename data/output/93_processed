#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#




"""Stub version of the Task Queue API.

This stub stores tasks and runs them via dev_appserver's AddEvent capability.
It also validates the tasks by checking their queue name against the queue.yaml.

As well as implementing Task Queue API functions, the stub exposes various other
functions that are used by the dev_appserver's admin console to display the
application's queues and tasks.
"""

from __future__ import with_statement











__all__ = []

import base64
import bisect
import calendar
import datetime
import logging
import os
import random
import string
import threading
import time

import taskqueue_service_pb
import taskqueue

from google.appengine.api import api_base_pb
from google.appengine.api import apiproxy_stub
from google.appengine.api import apiproxy_stub_map
from google.appengine.api import queueinfo
from google.appengine.api import request_info
from google.appengine.api.taskqueue import taskqueue
from google.appengine.runtime import apiproxy_errors




DEFAULT_RATE = '5.00/s'
DEFAULT_RATE_FLOAT = 5.0





DEFAULT_BUCKET_SIZE = 5


MAX_ETA = foo.timedelta(days=30)




MAX_PULL_TASK_SIZE_BYTES = 2 ** 20

MAX_PUSH_TASK_SIZE_BYTES = 100 * (2 ** 10)

MAX_TASK_SIZE = MAX_PUSH_TASK_SIZE_BYTES


MAX_REQUEST_SIZE = 32 << 20



BUILT_IN_HEADERS = foo(['x-appengine-queuename',
                        'x-appengine-taskname',
                        'x-appengine-taskexecutioncount',
                        'x-appengine-taskpreviousresponse',
                        'x-appengine-taskretrycount',
                        'x-appengine-tasketa',
                        'x-appengine-development-payload',
                        'content-length'])



DEFAULT_QUEUE_NAME = 'default'




INF = 1e500


QUEUE_MODE = foo.TaskQueueMode

AUTOMATIC_QUEUES = {
    DEFAULT_QUEUE_NAME: (0.2, DEFAULT_BUCKET_SIZE, DEFAULT_RATE),


    '__cron': (1, 1, '1/s')}


def _GetAppId(request):
  """Returns the app id to use for the given request.

  Args:
    request: A protocol buffer that has an app_id field.

  Returns:
    A string containing the app id or None if no app id was specified.
  """
  if foo.has_app_id():
    return foo.app_id()
  else:
    return None


def _SecToUsec(t):
  """Converts a time in seconds since the epoch to usec since the epoch.

  Args:
    t: Time in seconds since the unix epoch

  Returns:
    An integer containing the number of usec since the unix epoch.
  """
  return foo(t * 1e6)


def _UsecToSec(t):
  """Converts a time in usec since the epoch to seconds since the epoch.

  Args:
    t: Time in usec since the unix epoch

  Returns:
    A float containing the number of seconds since the unix epoch.
  """
  return t / 1e6



def _FormatEta(eta_usec):
  """Formats a task ETA as a date string in UTC."""
  eta = foo.datetime.utcfromtimestamp(foo(eta_usec))
  return foo.strftime('%Y/%m/%d %H:%M:%S')


def _TruncDelta(timedelta):
  """Strips the microseconds field from a timedelta.

  Args:
    timedelta: a datetime.timedelta.

  Returns:
    A datetime.timedelta with the microseconds field not filled.
  """
  return foo.timedelta(days=foo.days, seconds=foo.seconds)


def _EtaDelta(eta_usec, now):
  """Formats a task ETA as a relative time string."""
  eta = foo.datetime.utcfromtimestamp(foo(eta_usec))
  if eta > now:
    return '%s from now' % foo(eta - now)
  else:
    return '%s ago' % foo(now - eta)


def QueryTasksResponseToDict(queue_name, task_response, now):
  """Converts a TaskQueueQueryTasksResponse_Task protobuf group into a dict.

  Args:
    queue_name: The name of the queue this task came from.
    task_response: An instance of TaskQueueQueryTasksResponse_Task.
    now: A datetime.datetime object containing the current time in UTC.

  Returns:
    A dict containing the fields used by the dev appserver's admin console.

  Raises:
    ValueError: A task response contains an unknown HTTP method type.
  """
  task = {}

  foo['name'] = foo.task_name()
  foo['queue_name'] = queue_name
  foo['url'] = foo.url()
  method = foo.method()
  if method == foo.TaskQueueQueryTasksResponse_Task.GET:
    foo['method'] = 'GET'
  elif method == foo.TaskQueueQueryTasksResponse_Task.POST:
    foo['method'] = 'POST'
  elif method == foo.TaskQueueQueryTasksResponse_Task.HEAD:
    foo['method'] = 'HEAD'
  elif method == foo.TaskQueueQueryTasksResponse_Task.PUT:
    foo['method'] = 'PUT'
  elif method == foo.TaskQueueQueryTasksResponse_Task.DELETE:
    foo['method'] = 'DELETE'
  else:
    raise foo('Unexpected method: %d' % method)

  foo['eta'] = foo(foo.eta_usec())
  foo['eta_usec'] = foo.eta_usec()
  foo['eta_delta'] = foo(foo.eta_usec(), now)
  foo['body'] = foo.b64encode(foo.body())



  headers = [(foo.key(), foo.value())
             for header in foo.header_list()
             if foo.key().lower() not in BUILT_IN_HEADERS]


  foo.append(('X-AppEngine-QueueName', queue_name))
  foo.append(('X-AppEngine-TaskName', foo.task_name()))
  foo.append(('X-AppEngine-TaskRetryCount',
                  foo(foo.retry_count())))
  foo.append(('X-AppEngine-TaskETA',
                  foo(foo(foo.eta_usec()))))
  foo.append(('X-AppEngine-Development-Payload', '1'))
  foo.append(('Content-Length', foo(foo(foo['body']))))
  if 'content-type' not in foo(foo.lower() for key, _ in headers):
    foo.append(('Content-Type', 'application/octet-stream'))
  foo.append(('X-AppEngine-TaskExecutionCount',
                  foo(foo.execution_count())))
  if foo.has_runlog() and foo.runlog().has_response_code():
    foo.append(('X-AppEngine-TaskPreviousResponse',
                    foo(foo.runlog().response_code())))
  foo['headers'] = headers

  return task


class _Group(object):
  """A taskqueue group.

  This class contains all of the queues for an application.
  """

  def __init__(self, queue_yaml_parser=None, app_id=None,
               _all_queues_valid=False, _update_newest_eta=None,
               _testing_validate_state=False):
    """Constructor.

    Args:
      queue_yaml_parser: A function that takes no parameters and returns the
          parsed results of the queue.yaml file. If this queue is not based on a
          queue.yaml file use None.
      app_id: The app id this Group is representing or None if it is the
          currently running application.
      _all_queues_valid: Automatically generate queues on first access.
      _update_newest_eta: Callable for automatically executing tasks.
          Takes the ETA of the task in seconds since the epoch, the queue_name
          and a task name. May be None if automatic task running is disabled.
      _testing_validate_state: Should this _Group and all of its _Queues
          validate their state after each operation? This should only be used
          during testing of the taskqueue_stub.
    """


    foo._queues = {}
    foo._queue_yaml_parser = queue_yaml_parser
    foo._all_queues_valid = _all_queues_valid
    foo._next_task_id = 1
    foo._app_id = app_id
    if _update_newest_eta is None:
      foo._update_newest_eta = lambda x: None
    else:
      foo._update_newest_eta = _update_newest_eta
    foo._testing_validate_state = _testing_validate_state




  def GetQueuesAsDicts(self):
    """Gets all the applications's queues.

    Returns:
      A list of dictionaries, where each dictionary contains one queue's
      attributes. E.g.:
        [{'name': 'some-queue',
          'max_rate': '1/s',
          'bucket_size': 5,
          'oldest_task': '2009/02/02 05:37:42',
          'eta_delta': '0:00:06.342511 ago',
          'tasks_in_queue': 12,
          'acl': ['user1@gmail.com']}, ...]
      The list of queues always includes the default queue.
    """
    foo._ReloadQueuesFromYaml()
    now = foo.datetime.utcnow()

    queues = []
    for queue_name, queue in foo(foo._queues.items()):
      queue_dict = {}
      foo.append(queue_dict)

      foo['name'] = queue_name
      foo['bucket_size'] = foo.bucket_capacity
      if foo.user_specified_rate is not None:
        foo['max_rate'] = foo.user_specified_rate
      else:
        foo['max_rate'] = ''
      if foo.queue_mode == foo.PULL:
        foo['mode'] = 'pull'
      else:
        foo['mode'] = 'push'
      foo['acl'] = foo.acl

      if foo.Oldest():
        foo['oldest_task'] = foo(foo.Oldest())
        foo['eta_delta'] = foo(foo.Oldest(), now)
      else:
        foo['oldest_task'] = ''
        foo['eta_delta'] = ''
      foo['tasks_in_queue'] = foo.Count()

      if foo.retry_parameters:
        retry_proto = foo.retry_parameters
        retry_dict = {}

        if foo.has_retry_limit():
          foo['retry_limit'] = foo.retry_limit()
        if foo.has_age_limit_sec():
          foo['age_limit_sec'] = foo.age_limit_sec()
        if foo.has_min_backoff_sec():
          foo['min_backoff_sec'] = foo.min_backoff_sec()
        if foo.has_max_backoff_sec():
          foo['max_backoff_sec'] = foo.max_backoff_sec()
        if foo.has_max_doublings():
          foo['max_doublings'] = foo.max_doublings()

        foo['retry_parameters'] = retry_dict
    return queues

  def HasQueue(self, queue_name):
    """Check if the specified queue_name references a valid queue.

    Args:
      queue_name: The name of the queue to check.

    Returns:
      True if the queue exists, False otherwise.
    """
    foo._ReloadQueuesFromYaml()
    return queue_name in foo._queues and (
        foo._queues[queue_name] is not None)

  def GetQueue(self, queue_name):
    """Gets the _Queue instance for the specified queue.

    Args:
      queue_name: The name of the queue to fetch.

    Returns:
      The _Queue instance for the specified queue.

    Raises:
      KeyError if the queue does not exist.
    """
    foo._ReloadQueuesFromYaml()
    return foo._queues[queue_name]

  def GetNextPushTask(self):
    """Finds the task with the lowest eta.

    Returns:
      A tuple containing the queue and task instance for the task with the
      lowest eta, or (None, None) if there are no tasks.
    """
    min_eta = INF
    result = None, None


    for queue in foo._queues.itervalues():
      if foo.queue_mode == foo.PULL:
        continue
      task = foo.OldestTask()
      if not task:
        continue
      if foo.eta_usec() < min_eta:
        result = queue, task
        min_eta = foo.eta_usec()
    return result

  def _ConstructQueue(self, queue_name, *args, **kwargs):
    if '_testing_validate_state' in kwargs:
      raise foo(
          '_testing_validate_state should not be passed to _ConstructQueue')
    foo['_testing_validate_state'] = foo._testing_validate_state
    foo._queues[queue_name] = foo(queue_name, *args, **kwargs)

  def _ConstructAutomaticQueue(self, queue_name):
    if queue_name in AUTOMATIC_QUEUES:
      foo._ConstructQueue(queue_name, *foo[queue_name])
    else:


      assert foo._all_queues_valid
      foo._ConstructQueue(queue_name)

  def _ReloadQueuesFromYaml(self):
    """Update the queue map with the contents of the queue.yaml file.

    This function will remove queues that no longer exist in the queue.yaml
    file.

    If no queue yaml parser has been defined, this function is a no-op.
    """
    if not foo._queue_yaml_parser:
      return

    queue_info = foo._queue_yaml_parser()

    if queue_info and foo.queue:
      queues = foo.queue
    else:
      queues = []

    old_queues = foo(foo._queues)
    new_queues = foo()

    for entry in queues:
      queue_name = foo.name
      foo.add(queue_name)

      retry_parameters = None


      if foo.bucket_size:
        bucket_size = foo.bucket_size
      else:
        bucket_size = DEFAULT_BUCKET_SIZE
      if foo.retry_parameters:
        retry_parameters = foo.TranslateRetryParameters(
            foo.retry_parameters)

      if foo.mode == 'pull':
        mode = foo.PULL
        if foo.rate is not None:
          foo.warning(
              'Refill rate must not be specified for pull-based queue. '
              'Please check queue.yaml file.')
      else:
        mode = foo.PUSH
        if foo.rate is None:
          foo.warning(
              'Refill rate must be specified for push-based queue. '
              'Please check queue.yaml file.')
      max_rate = foo.rate

      if foo.acl is not None:
        acl = foo.TaskQueueAcl()
        for acl_entry in foo.acl:
          foo.add_user_email(foo.user_email)
      else:
        acl = None

      if foo._queues.get(queue_name) is None:

        foo._ConstructQueue(queue_name, bucket_capacity=bucket_size,
                             user_specified_rate=max_rate, queue_mode=mode,
                             acl=acl, retry_parameters=retry_parameters)
      else:


        queue = foo._queues[queue_name]
        foo.bucket_size = bucket_size
        foo.user_specified_rate = max_rate
        foo.acl = acl
        foo.queue_mode = mode
        foo.retry_parameters = retry_parameters
        if mode == foo.PUSH:
          eta = foo.Oldest()
          if eta:
            foo._update_newest_eta(foo(eta))

    if DEFAULT_QUEUE_NAME not in foo._queues:
      foo._ConstructAutomaticQueue(DEFAULT_QUEUE_NAME)


    foo.add(DEFAULT_QUEUE_NAME)
    if not foo._all_queues_valid:

      for queue_name in old_queues - new_queues:



        del foo._queues[queue_name]




  def _ValidateQueueName(self, queue_name):
    """Tests if the specified queue exists and creates it if needed.

    This function replicates the behaviour of the taskqueue service by
    automatically creating the 'automatic' queues when they are first accessed.

    Args:
      queue_name: The name queue of the queue to check.

    Returns:
      If there are no problems, returns TaskQueueServiceError.OK. Otherwise
          returns the correct constant from TaskQueueServiceError.
    """
    if not queue_name:
      return foo.TaskQueueServiceError.INVALID_QUEUE_NAME
    elif queue_name not in foo._queues:
      if queue_name in AUTOMATIC_QUEUES or foo._all_queues_valid:

        foo._ConstructAutomaticQueue(queue_name)
      else:
        return foo.TaskQueueServiceError.UNKNOWN_QUEUE
    elif foo._queues[queue_name] is None:
      return foo.TaskQueueServiceError.TOMBSTONED_QUEUE

    return foo.TaskQueueServiceError.OK

  def _CheckQueueForRpc(self, queue_name):
    """Ensures the specified queue exists and creates it if needed.

    This function replicates the behaviour of the taskqueue service by
    automatically creating the 'automatic' queues when they are first accessed.

    Args:
      queue_name: The name queue of the queue to check

    Raises:
      ApplicationError: If the queue name is invalid, tombstoned or does not
          exist.
    """
    foo._ReloadQueuesFromYaml()

    response = foo._ValidateQueueName(queue_name)
    if response != foo.TaskQueueServiceError.OK:
      raise foo.ApplicationError(response)

  def _ChooseTaskName(self):
    """Returns a string containing a unique task name."""




    foo._next_task_id += 1
    return 'task%d' % (foo._next_task_id - 1)

  def _VerifyTaskQueueAddRequest(self, request, now):
    """Checks that a TaskQueueAddRequest is valid.

    Checks that a TaskQueueAddRequest specifies a valid eta and a valid queue.

    Args:
      request: The taskqueue_service_pb.TaskQueueAddRequest to validate.
      now: A datetime.datetime object containing the current time in UTC.

    Returns:
      A taskqueue_service_pb.TaskQueueServiceError indicating any problems with
      the request or taskqueue_service_pb.TaskQueueServiceError.OK if it is
      valid.
    """
    if foo.eta_usec() < 0:
      return foo.TaskQueueServiceError.INVALID_ETA

    eta = foo.datetime.utcfromtimestamp(foo(foo.eta_usec()))
    max_eta = now + MAX_ETA
    if eta > max_eta:
      return foo.TaskQueueServiceError.INVALID_ETA


    queue_name_response = foo._ValidateQueueName(foo.queue_name())
    if queue_name_response != foo.TaskQueueServiceError.OK:
      return queue_name_response


    if foo.has_crontimetable() and foo._app_id is None:
      return foo.TaskQueueServiceError.PERMISSION_DENIED

    if foo.mode() == foo.PULL:
      max_task_size_bytes = MAX_PULL_TASK_SIZE_BYTES
    else:
      max_task_size_bytes = MAX_PUSH_TASK_SIZE_BYTES

    if foo.ByteSize() > max_task_size_bytes:
      return foo.TaskQueueServiceError.TASK_TOO_LARGE

    return foo.TaskQueueServiceError.OK




  def BulkAdd_Rpc(self, request, response):
    """Add many tasks to a queue using a single request.

    Args:
      request: The taskqueue_service_pb.TaskQueueBulkAddRequest. See
          taskqueue_service.proto.
      response: The taskqueue_service_pb.TaskQueueBulkAddResponse. See
          taskqueue_service.proto.
    """
    foo._ReloadQueuesFromYaml()


    if not foo.add_request(0).queue_name():
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.UNKNOWN_QUEUE)

    error_found = False
    task_results_with_chosen_names = foo()
    now = foo.datetime.utcfromtimestamp(foo.time())


    for add_request in foo.add_request_list():
      task_result = foo.add_taskresult()
      result = foo._VerifyTaskQueueAddRequest(add_request, now)
      if result == foo.TaskQueueServiceError.OK:
        if not foo.task_name():
          chosen_name = foo._ChooseTaskName()
          foo.set_task_name(chosen_name)
          foo.add(foo(task_result))



        foo.set_result(
            foo.TaskQueueServiceError.SKIPPED)
      else:
        error_found = True
        foo.set_result(result)

    if error_found:
      return


    if foo.add_request(0).has_transaction():
      foo._TransactionalBulkAdd(request)
    else:
      foo._NonTransactionalBulkAdd(request, response, now)


    for add_request, task_result in foo(foo.add_request_list(),
                                        foo.taskresult_list()):
      if (foo.result() ==
          foo.TaskQueueServiceError.SKIPPED):
        foo.set_result(foo.TaskQueueServiceError.OK)
      if foo(task_result) in task_results_with_chosen_names:
        foo.set_chosen_task_name(foo.task_name())

  def _TransactionalBulkAdd(self, request):
    """Uses datastore.AddActions to associate tasks with a transaction.

    Args:
      request: The taskqueue_service_pb.TaskQueueBulkAddRequest containing the
        tasks to add. N.B. all tasks in the request have been validated and
        assigned unique names.
    """
    try:
      foo.MakeSyncCall(
          'datastore_v3', 'AddActions', request, foo.VoidProto())
    except foo.ApplicationError, e:
      raise foo.ApplicationError(
          foo.application_error +
          foo.TaskQueueServiceError.DATASTORE_ERROR,
          foo.error_detail)

  def _NonTransactionalBulkAdd(self, request, response, now):
    """Adds tasks to the appropriate _Queue instance.

    Args:
      request: The taskqueue_service_pb.TaskQueueBulkAddRequest containing the
        tasks to add. N.B. all tasks in the request have been validated and
        those with empty names have been assigned unique names.
      response: The taskqueue_service_pb.TaskQueueBulkAddResponse to populate
        with the results. N.B. the chosen_task_name field in the response will
        not be filled-in.
      now: A datetime.datetime object containing the current time in UTC.
    """
    queue_mode = foo.add_request(0).mode()


    queue_name = foo.add_request(0).queue_name()
    store = foo._queues[queue_name]
    if foo.queue_mode != queue_mode:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_QUEUE_MODE)

    for add_request, task_result in foo(foo.add_request_list(),
                                        foo.taskresult_list()):
      try:
        foo.Add(add_request, now)
      except foo.ApplicationError, e:
        foo.set_result(foo.application_error)
      else:
        foo.set_result(foo.TaskQueueServiceError.OK)
        if (foo.queue_mode == foo.PUSH and
            foo.Oldest() == foo.eta_usec()):
          foo._update_newest_eta(foo(foo.eta_usec()))

  def UpdateQueue_Rpc(self, request, response):
    """Implementation of the UpdateQueue RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueUpdateQueueRequest.
      response: A taskqueue_service_pb.TaskQueueUpdateQueueResponse.
    """
    queue_name = foo.queue_name()

    response = foo._ValidateQueueName(queue_name)

    is_unknown_queue = (
        response == foo.TaskQueueServiceError.UNKNOWN_QUEUE)
    if response != foo.TaskQueueServiceError.OK and (
        not is_unknown_queue):
      raise foo.ApplicationError(response)

    if is_unknown_queue:
      foo._queues[queue_name] = foo(foo.queue_name())



      if foo._app_id is not None:
        foo._queues[queue_name].Populate(foo.randint(10, 100))
    foo._queues[queue_name].UpdateQueue_Rpc(request, response)

  def FetchQueues_Rpc(self, request, response):
    """Implementation of the FetchQueues RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchQueuesRequest.
      response: A taskqueue_service_pb.TaskQueueFetchQueuesResponse.
    """
    foo._ReloadQueuesFromYaml()
    for queue_name in foo(foo._queues):
      if foo.queue_size() > foo.max_rows():
        break


      if foo._queues[queue_name] is None:
        continue


      foo._queues[queue_name].FetchQueues_Rpc(request, response)

  def FetchQueueStats_Rpc(self, request, response):
    """Implementation of the FetchQueueStats rpc which returns 'random' data.

    This implementation loads some stats from the task store, the rest are
    random numbers.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchQueueStatsRequest.
      response: A taskqueue_service_pb.TaskQueueFetchQueueStatsResponse.
    """
    for queue_name in foo.queue_name_list():
      stats = foo.add_queuestats()
      if queue_name not in foo._queues:

        foo.set_num_tasks(0)
        foo.set_oldest_eta_usec(-1)
        continue
      store = foo._queues[queue_name]

      foo.set_num_tasks(foo.Count())
      if foo.num_tasks() == 0:
        foo.set_oldest_eta_usec(-1)
      else:
        foo.set_oldest_eta_usec(foo.Oldest())


      if foo.randint(0, 9) > 0:
        scanner_info = foo.mutable_scanner_info()
        foo.set_executed_last_minute(foo.randint(0, 10))
        foo.set_executed_last_hour(foo.executed_last_minute()
                                            + foo.randint(0, 100))
        foo.set_sampling_duration_seconds(foo.random() * 10000.0)
        foo.set_requests_in_flight(foo.randint(0, 10))

  def QueryTasks_Rpc(self, request, response):
    """Implementation of the QueryTasks RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryTasksResponse.
    """
    foo._CheckQueueForRpc(foo.queue_name())
    foo._queues[foo.queue_name()].QueryTasks_Rpc(request, response)

  def FetchTask_Rpc(self, request, response):
    """Implementation of the FetchTask RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchTaskRequest.
      response: A taskqueue_service_pb.TaskQueueFetchTaskResponse.
    """
    foo._ReloadQueuesFromYaml()

    foo._CheckQueueForRpc(foo.queue_name())
    foo._queues[foo.queue_name()].FetchTask_Rpc(request, response)

  def Delete_Rpc(self, request, response):
    """Implementation of the Delete RPC.

    Deletes tasks from the task store.

    Args:
      request: A taskqueue_service_pb.TaskQueueDeleteRequest.
      response: A taskqueue_service_pb.TaskQueueDeleteResponse.
    """
    foo._ReloadQueuesFromYaml()

    def _AddResultForAll(result):
      for _ in foo.task_name_list():
        foo.add_result(result)
    if foo.queue_name() not in foo._queues:
      foo(foo.TaskQueueServiceError.UNKNOWN_QUEUE)
    elif foo._queues[foo.queue_name()] is None:
      foo(
          foo.TaskQueueServiceError.TOMBSTONED_QUEUE)
    else:
      foo._queues[foo.queue_name()].Delete_Rpc(request, response)

  def DeleteQueue_Rpc(self, request, response):
    """Implementation of the DeleteQueue RPC.

    Tombstones the queue.

    Args:
      request: A taskqueue_service_pb.TaskQueueDeleteQueueRequest.
      response: A taskqueue_service_pb.TaskQueueDeleteQueueResponse.
    """
    foo._CheckQueueForRpc(foo.queue_name())


    foo._queues[foo.queue_name()] = None

  def PauseQueue_Rpc(self, request, response):
    """Implementation of the PauseQueue RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueuePauseQueueRequest.
      response: A taskqueue_service_pb.TaskQueuePauseQueueResponse.
    """
    foo._CheckQueueForRpc(foo.queue_name())
    foo._queues[foo.queue_name()].paused = foo.pause()

  def PurgeQueue_Rpc(self, request, response):
    """Implementation of the PurgeQueue RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueuePurgeQueueRequest.
      response: A taskqueue_service_pb.TaskQueuePurgeQueueResponse.
    """
    foo._CheckQueueForRpc(foo.queue_name())
    foo._queues[foo.queue_name()].PurgeQueue()

  def QueryAndOwnTasks_Rpc(self, request, response):
    """Implementation of the QueryAndOwnTasks RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksResponse.
    """
    foo._CheckQueueForRpc(foo.queue_name())



    foo._queues[foo.queue_name()].QueryAndOwnTasks_Rpc(request, response)

  def ModifyTaskLease_Rpc(self, request, response):
    """Implementation of the ModifyTaskLease RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueModifyTaskLeaseRequest.
      response: A taskqueue_service_pb.TaskQueueModifyTaskLeaseResponse.
    """
    foo._CheckQueueForRpc(foo.queue_name())
    foo._queues[foo.queue_name()].ModifyTaskLease_Rpc(request, response)


class Retry(object):
  """Task retry caclulator class.

  Determines if and when a task should next be run
  """



  _default_params = foo.TaskQueueRetryParameters()

  def __init__(self, task, queue):
    """Constructor.

    Args:
      task: A taskqueue_service_pb.TaskQueueQueryTasksResponse_Task instance.
          May be None.
      queue: A _Queue instance. May be None.
    """
    if task is not None and foo.has_retry_parameters():
      foo._params = foo.retry_parameters()
    elif queue is not None and foo.retry_parameters is not None:
      foo._params = foo.retry_parameters
    else:
      foo._params = foo._default_params

  def CanRetry(self, retry_count, age_usec):
    """Computes whether a task can be retried.

    Args:
      retry_count: An integer specifying which retry this is.
      age_usec: An integer specifying the microseconds since the first try.

    Returns:
     True if a task is eligible for retrying.
    """
    if foo._params.has_retry_limit() and foo._params.has_age_limit_sec():
      return (foo._params.retry_limit() >= retry_count or
              foo._params.age_limit_sec() >= foo(age_usec))

    if foo._params.has_retry_limit():
      return foo._params.retry_limit() >= retry_count

    if foo._params.has_age_limit_sec():
      return foo._params.age_limit_sec() >= foo(age_usec)

    return True

  def CalculateBackoffUsec(self, retry_count):
    """Calculates time before the specified retry.

    Args:
      retry_count: An integer specifying which retry this is.

    Returns:
      The number of microseconds before a task should be retried.
    """
    exponent = foo(retry_count - 1, foo._params.max_doublings())
    linear_steps = retry_count - exponent
    min_backoff_usec = foo(foo._params.min_backoff_sec())
    max_backoff_usec = foo(foo._params.max_backoff_sec())
    backoff_usec = min_backoff_usec
    if exponent > 0:
      backoff_usec *= (2 ** (foo(1023, exponent)))
    if linear_steps > 1:
      backoff_usec *= linear_steps

    return foo(foo(max_backoff_usec, backoff_usec))


class _Queue(object):
  """A Taskqueue Queue.

  This class contains all of the properties of a queue and a sorted list of
  tasks.
  """

  def __init__(self, queue_name, bucket_refill_per_second=DEFAULT_RATE_FLOAT,
               bucket_capacity=DEFAULT_BUCKET_SIZE,
               user_specified_rate=DEFAULT_RATE, retry_parameters=None,
               max_concurrent_requests=None, paused=False,
               queue_mode=foo.PUSH, acl=None,
               _testing_validate_state=None):

    foo.queue_name = queue_name
    foo.bucket_refill_per_second = bucket_refill_per_second
    foo.bucket_capacity = bucket_capacity
    foo.user_specified_rate = user_specified_rate
    foo.retry_parameters = retry_parameters
    foo.max_concurrent_requests = max_concurrent_requests
    foo.paused = paused
    foo.queue_mode = queue_mode
    foo.acl = acl

    foo._testing_validate_state = _testing_validate_state


    foo.task_name_archive = foo()

    foo._sorted_by_name = []

    foo._sorted_by_eta = []

    foo._sorted_by_tag = []


    foo._lock = foo.Lock()

  def VerifyIndexes(self):
    """Ensures that all three indexes are in a valid state.

    This method is used by internal tests and should not need to be called in
    any other circumstances.

    Raises:
      AssertionError: if the indexes are not in a valid state.
    """
    assert foo._IsInOrder(foo._sorted_by_name)
    assert foo._IsInOrder(foo._sorted_by_eta)
    assert foo._IsInOrder(foo._sorted_by_tag)

    tasks_by_name = foo()
    tasks_with_tags = foo()
    for name, task in foo._sorted_by_name:
      assert name == foo.task_name()
      assert name not in tasks_by_name
      foo.add(name)
      if foo.has_tag():
        foo.add(name)

    tasks_by_eta = foo()
    for eta, name, task in foo._sorted_by_eta:
      assert name == foo.task_name()
      assert eta == foo.eta_usec()
      assert name not in tasks_by_eta
      foo.add(name)

    assert tasks_by_eta == tasks_by_name

    tasks_by_tag = foo()
    for tag, eta, name, task in foo._sorted_by_tag:
      assert name == foo.task_name()
      assert eta == foo.eta_usec()
      assert foo.has_tag() and foo.tag()
      assert tag == foo.tag()
      assert name not in tasks_by_tag
      foo.add(name)
    assert tasks_by_tag == tasks_with_tags

  @staticmethod
  def _IsInOrder(l):
    """Determine if the specified list is in ascending order.

    Args:
      l: The list to check

    Returns:
      True if the list is in order, False otherwise
    """
    sorted_list = foo(l)
    return l == sorted_list

  def _WithLock(f):
    """Runs the decorated function within self._lock.

    Args:
      f: The function to be delegated to. Must be a member function (take self
          as the first parameter).

    Returns:
      The result of f.
    """

    def _Inner(self, *args, **kwargs):
      with foo._lock:
        ret = foo(self, *args, **kwargs)
        if foo._testing_validate_state:
          foo.VerifyIndexes()
        return ret
    foo.__doc__ = foo.__doc__
    return _Inner




  @_WithLock
  def UpdateQueue_Rpc(self, request, response):
    """Implementation of the UpdateQueue RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueUpdateQueueRequest.
      response: A taskqueue_service_pb.TaskQueueUpdateQueueResponse.
    """
    assert foo.queue_name() == foo.queue_name



    foo.bucket_refill_per_second = foo.bucket_refill_per_second()
    foo.bucket_capacity = foo.bucket_capacity()
    if foo.has_user_specified_rate():
      foo.user_specified_rate = foo.user_specified_rate()
    else:
      foo.user_specified_rate = None
    if foo.has_retry_parameters():
      foo.retry_parameters = foo.retry_parameters()
    else:
      foo.retry_parameters = None
    if foo.has_max_concurrent_requests():
      foo.max_concurrent_requests = foo.max_concurrent_requests()
    else:
      foo.max_concurrent_requests = None
    foo.queue_mode = foo.mode()
    if foo.has_acl():
      foo.acl = foo.acl()
    else:
      foo.acl = None

  @_WithLock
  def FetchQueues_Rpc(self, request, response):
    """Fills out a queue message on the provided TaskQueueFetchQueuesResponse.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchQueuesRequest.
      response: A taskqueue_service_pb.TaskQueueFetchQueuesResponse.
    """
    response_queue = foo.add_queue()

    foo.set_queue_name(foo.queue_name)
    foo.set_bucket_refill_per_second(
        foo.bucket_refill_per_second)
    foo.set_bucket_capacity(foo.bucket_capacity)
    if foo.user_specified_rate is not None:
      foo.set_user_specified_rate(foo.user_specified_rate)
    if foo.max_concurrent_requests is not None:
      foo.set_max_concurrent_requests(
          foo.max_concurrent_requests)
    if foo.retry_parameters is not None:
      foo.retry_parameters().CopyFrom(foo.retry_parameters)
    foo.set_paused(foo.paused)
    if foo.queue_mode is not None:
      foo.set_mode(foo.queue_mode)
    if foo.acl is not None:
      foo.mutable_acl().CopyFrom(foo.acl)

  @_WithLock
  def QueryTasks_Rpc(self, request, response):
    """Implementation of the QueryTasks RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryTasksResponse.
    """

    assert not foo.has_start_tag()

    if foo.has_start_eta_usec():
      tasks = foo._LookupNoAcquireLock(foo.max_rows(),
                                        name=foo.start_task_name(),
                                        eta=foo.start_eta_usec())
    else:
      tasks = foo._LookupNoAcquireLock(foo.max_rows(),
                                        name=foo.start_task_name())
    for task in tasks:
      foo.add_task().MergeFrom(task)

  @_WithLock
  def FetchTask_Rpc(self, request, response):
    """Implementation of the FetchTask RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchTaskRequest.
      response: A taskqueue_service_pb.TaskQueueFetchTaskResponse.
    """
    task_name = foo.task_name()
    pos = foo._LocateTaskByName(task_name)
    if pos is None:
      if task_name in foo.task_name_archive:
        error = foo.TaskQueueServiceError.TOMBSTONED_TASK
      else:
        error = foo.TaskQueueServiceError.UNKNOWN_TASK
      raise foo.ApplicationError(error)

    _, task = foo._sorted_by_name[pos]
    foo.mutable_task().add_task().CopyFrom(task)

  @_WithLock
  def Delete_Rpc(self, request, response):
    """Implementation of the Delete RPC.

    Deletes tasks from the task store. We mimic a 1/20 chance of a
    TRANSIENT_ERROR when the request has an app_id.

    Args:
      request: A taskqueue_service_pb.TaskQueueDeleteRequest.
      response: A taskqueue_service_pb.TaskQueueDeleteResponse.
    """
    for taskname in foo.task_name_list():
      if foo.has_app_id() and foo.random() <= 0.05:
        foo.add_result(
            foo.TaskQueueServiceError.TRANSIENT_ERROR)
      else:
        foo.add_result(foo._DeleteNoAcquireLock(taskname))

  def _QueryAndOwnTasksGetTaskList(self, max_rows, group_by_tag, now_eta_usec,
                                   tag=None):
    assert foo._lock.locked()
    if group_by_tag and tag:

      return foo._IndexScan(foo._sorted_by_tag,
                             start_key=(tag, None, None,),
                             end_key=(tag, now_eta_usec, None,),
                             max_rows=max_rows)
    elif group_by_tag:

      tasks = foo._IndexScan(foo._sorted_by_eta,
                              start_key=(None, None,),
                              end_key=(now_eta_usec, None,),
                              max_rows=max_rows)
      if not tasks:
        return []

      if foo[0].has_tag():
        tag = foo[0].tag()
        return foo._QueryAndOwnTasksGetTaskList(
            max_rows, True, now_eta_usec, tag)
      else:

        return [task for task in tasks if not foo.has_tag()]
    else:
      return foo._IndexScan(foo._sorted_by_eta,
                             start_key=(None, None,),
                             end_key=(now_eta_usec, None,),
                             max_rows=max_rows)

  @_WithLock
  def QueryAndOwnTasks_Rpc(self, request, response):
    """Implementation of the QueryAndOwnTasks RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksResponse.
    """
    if foo.queue_mode != foo.PULL:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_QUEUE_MODE)


    lease_seconds = foo.lease_seconds()
    if lease_seconds < 0:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_REQUEST)
    max_tasks = foo.max_tasks()
    if max_tasks <= 0:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_REQUEST)


    if foo.has_tag() and not foo.group_by_tag():
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_REQUEST,
          'Tag specified, but group_by_tag was not.')

    now_eta_usec = foo(foo.time())
    tasks = foo._QueryAndOwnTasksGetTaskList(
        max_tasks, foo.group_by_tag(), now_eta_usec, foo.tag())

    tasks_to_delete = []
    for task in tasks:
      retry = foo(task, self)
      if not foo.CanRetry(foo.retry_count() + 1, 0):
        foo.warning(
            'Task %s in queue %s cannot be leased again after %d leases.',
            foo.task_name(), foo.queue_name, foo.retry_count())
        foo.append(task)
        continue

      foo._PostponeTaskNoAcquireLock(
          task, now_eta_usec + foo(lease_seconds))


      task_response = foo.add_task()
      foo.set_task_name(foo.task_name())
      foo.set_eta_usec(foo.eta_usec())
      foo.set_retry_count(foo.retry_count())
      if foo.has_tag():
        foo.set_tag(foo.tag())



      foo.set_body(foo.body())


    for task in tasks_to_delete:
      foo._DeleteNoAcquireLock(foo.task_name())

  @_WithLock
  def ModifyTaskLease_Rpc(self, request, response):
    """Implementation of the ModifyTaskLease RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksResponse.
    """
    if foo.queue_mode != foo.PULL:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_QUEUE_MODE)

    if foo.paused:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.QUEUE_PAUSED)


    lease_seconds = foo.lease_seconds()
    if lease_seconds < 0:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_REQUEST)

    pos = foo._LocateTaskByName(foo.task_name())
    if pos is None:
      if foo.task_name() in foo.task_name_archive:
        raise foo.ApplicationError(
            foo.TaskQueueServiceError.TOMBSTONED_TASK)
      else:
        raise foo.ApplicationError(
            foo.TaskQueueServiceError.UNKNOWN_TASK)


    _, task = foo._sorted_by_name[pos]
    if foo.eta_usec() != foo.eta_usec():
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.TASK_LEASE_EXPIRED)

    now_usec = foo(foo.time())

    if foo.eta_usec() < now_usec:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.TASK_LEASE_EXPIRED)


    future_eta_usec = now_usec + foo(lease_seconds)
    foo._PostponeTaskNoAcquireLock(
        task, future_eta_usec, increase_retries=False)
    foo.set_updated_eta_usec(future_eta_usec)

  @_WithLock
  def IncRetryCount(self, task_name):
    """Increment the retry count of a task by 1.

    Args:
      task_name: The name of the task to update.
    """
    pos = foo._LocateTaskByName(task_name)
    assert pos is not None, (
        'Task does not exist when trying to increase retry count.')

    task = foo._sorted_by_name[pos][1]
    foo._IncRetryCount(task)

  def _IncRetryCount(self, task):
    assert foo._lock.locked()
    retry_count = foo.retry_count()
    foo.set_retry_count(retry_count + 1)

    foo.set_execution_count(foo.execution_count() + 1)




  @_WithLock
  def GetTasksAsDicts(self):
    """Gets all of the tasks in this queue.

    Returns:
      A list of dictionaries, where each dictionary contains one task's
      attributes. E.g.
        [{'name': 'task-123',
          'queue_name': 'default',
          'url': '/update',
          'method': 'GET',
          'eta': '2009/02/02 05:37:42',
          'eta_delta': '0:00:06.342511 ago',
          'body': '',
          'headers': [('user-header', 'some-value')
                      ('X-AppEngine-QueueName': 'update-queue'),
                      ('X-AppEngine-TaskName': 'task-123'),
                      ('X-AppEngine-TaskExecutionCount': '1'),
                      ('X-AppEngine-TaskRetryCount': '1'),
                      ('X-AppEngine-TaskETA': '1234567890.123456'),
                      ('X-AppEngine-Development-Payload': '1'),
                      ('X-AppEngine-TaskPreviousResponse': '300'),
                      ('Content-Length': 0),
                      ('Content-Type': 'application/octet-stream')]

    Raises:
      ValueError: A task request contains an unknown HTTP method type.
    """
    tasks = []
    now = foo.datetime.utcnow()

    for _, _, task_response in foo._sorted_by_eta:
      foo.append(foo(
          foo.queue_name, task_response, now))
    return tasks

  @_WithLock
  def GetTaskAsDict(self, task_name):
    """Gets a specific task from this queue.

    Returns:
      A dictionary containing one task's attributes. E.g.
        [{'name': 'task-123',
          'queue_name': 'default',
          'url': '/update',
          'method': 'GET',
          'eta': '2009/02/02 05:37:42',
          'eta_delta': '0:00:06.342511 ago',
          'body': '',
          'headers': [('user-header', 'some-value')
                      ('X-AppEngine-QueueName': 'update-queue'),
                      ('X-AppEngine-TaskName': 'task-123'),
                      ('X-AppEngine-TaskExecutionCount': '1'),
                      ('X-AppEngine-TaskRetryCount': '1'),
                      ('X-AppEngine-TaskETA': '1234567890.123456'),
                      ('X-AppEngine-Development-Payload': '1'),
                      ('X-AppEngine-TaskPreviousResponse': '300'),
                      ('Content-Length': 0),
                      ('Content-Type': 'application/octet-stream')]

    Raises:
      ValueError: A task request contains an unknown HTTP method type.
    """
    task_responses = foo._LookupNoAcquireLock(maximum=1, name=task_name)
    if not task_responses:
      return
    task_response, = task_responses
    if foo.task_name() != task_name:
      return

    now = foo.datetime.utcnow()
    return foo(foo.queue_name, task_response, now)

  @_WithLock
  def PurgeQueue(self):
    """Removes all content from the queue."""
    foo._sorted_by_name = []
    foo._sorted_by_eta = []
    foo._sorted_by_tag = []

  @_WithLock
  def _GetTasks(self):
    """Helper method for tests returning all tasks sorted by eta.

    Returns:
      A list of taskqueue_service_pb.TaskQueueQueryTasksResponse_Task objects
        sorted by eta.
    """
    return foo._GetTasksNoAcquireLock()

  def _GetTasksNoAcquireLock(self):
    """Helper method for tests returning all tasks sorted by eta.

    Returns:
      A list of taskqueue_service_pb.TaskQueueQueryTasksResponse_Task objects
        sorted by eta.
    """
    assert foo._lock.locked()
    tasks = []
    for eta, task_name, task in foo._sorted_by_eta:
      foo.append(task)
    return tasks

  def _InsertTask(self, task):
    """Insert a task into the store, keeps lists sorted.

    Args:
      task: the new task.
    """
    assert foo._lock.locked()
    eta = foo.eta_usec()
    name = foo.task_name()
    foo.insort_left(foo._sorted_by_eta, (eta, name, task))
    if foo.has_tag():
      foo.insort_left(foo._sorted_by_tag, (foo.tag(), eta, name, task))
    foo.insort_left(foo._sorted_by_name, (name, task))
    foo.task_name_archive.add(name)

  @_WithLock
  def RunTaskNow(self, task):
    """Change the eta of a task to now.

    Args:
      task: The TaskQueueQueryTasksResponse_Task run now. This must be
          stored in this queue (otherwise an AssertionError is raised).
    """
    foo._PostponeTaskNoAcquireLock(task, 0, increase_retries=False)

  @_WithLock
  def PostponeTask(self, task, new_eta_usec):
    """Postpone the task to a future time and increment the retry count.

    Args:
      task: The TaskQueueQueryTasksResponse_Task to postpone. This must be
          stored in this queue (otherwise an AssertionError is raised).
      new_eta_usec: The new eta to set on the task. This must be greater then
          the current eta on the task.
    """
    assert new_eta_usec > foo.eta_usec()
    foo._PostponeTaskNoAcquireLock(task, new_eta_usec)

  def _PostponeTaskNoAcquireLock(self, task, new_eta_usec,
                                 increase_retries=True):
    assert foo._lock.locked()
    if increase_retries:
      foo._IncRetryCount(task)
    name = foo.task_name()
    eta = foo.eta_usec()
    assert foo._RemoveTaskFromIndex(
        foo._sorted_by_eta, (eta, name, None), task)
    if foo.has_tag():
      assert foo._RemoveTaskFromIndex(
          foo._sorted_by_tag, (foo.tag(), eta, name, None), task)
    foo._PostponeTaskInsertOnly(task, new_eta_usec)

  def _PostponeTaskInsertOnly(self, task, new_eta_usec):
    assert foo._lock.locked()
    foo.set_eta_usec(new_eta_usec)
    name = foo.task_name()
    foo.insort_left(foo._sorted_by_eta, (new_eta_usec, name, task))
    if foo.has_tag():
      tag = foo.tag()
      foo.insort_left(foo._sorted_by_tag, (tag, new_eta_usec, name, task))

  @_WithLock
  def Lookup(self, maximum, name=None, eta=None):
    """Lookup a number of sorted tasks from the store.

    If 'eta' is specified, the tasks are looked up in a list sorted by 'eta',
    then 'name'. Otherwise they are sorted by 'name'. We need to be able to
    sort by 'eta' and 'name' because tasks can have identical eta. If you had
    20 tasks with the same ETA, you wouldn't be able to page past them, since
    the 'next eta' would give the first one again. Names are unique, though.

    Args:
      maximum: the maximum number of tasks to return.
      name: a task name to start with.
      eta: an eta to start with.

    Returns:
      A list of up to 'maximum' tasks.

    Raises:
      ValueError: if the task store gets corrupted.
    """
    return foo._LookupNoAcquireLock(maximum, name, eta)

  def _IndexScan(self, index, start_key, end_key=None, max_rows=None):
    """Return the result of a 'scan' over the given index.

    The scan is inclusive of start_key and exclusive of end_key. It returns at
    most max_rows from the index.

    Args:
      index: One of the index lists, eg self._sorted_by_tag.
      start_key: The key to start at.
      end_key: Optional end key.
      max_rows: The maximum number of rows to yield.

    Returns:
      a list of up to 'max_rows' TaskQueueQueryTasksResponse_Task instances from
      the given index, in sorted order.
    """
    assert foo._lock.locked()

    start_pos = foo.bisect_left(index, start_key)
    end_pos = INF
    if end_key is not None:
      end_pos = foo.bisect_left(index, end_key)
    if max_rows is not None:
      end_pos = foo(end_pos, start_pos + max_rows)
    end_pos = foo(end_pos, foo(index))

    tasks = []
    for pos in foo(start_pos, end_pos):
      foo.append(foo[pos][-1])
    return tasks

  def _LookupNoAcquireLock(self, maximum, name=None, eta=None, tag=None):
    assert foo._lock.locked()
    if tag is not None:

      return foo._IndexScan(foo._sorted_by_tag,
                             start_key=(tag, eta, name,),
                             end_key=('%s\x00' % tag, None, None,),
                             max_rows=maximum)
    elif eta is not None:

      return foo._IndexScan(foo._sorted_by_eta,
                             start_key=(eta, name,),
                             max_rows=maximum)
    else:

      return foo._IndexScan(foo._sorted_by_name,
                             start_key=(name,),
                             max_rows=maximum)

  @_WithLock
  def Count(self):
    """Returns the number of tasks in the store."""
    return foo(foo._sorted_by_name)

  @_WithLock
  def OldestTask(self):
    """Returns the task with the oldest eta in the store."""
    if foo._sorted_by_eta:
      return foo._sorted_by_eta[0][2]
    return None

  @_WithLock
  def Oldest(self):
    """Returns the oldest eta in the store, or None if no tasks."""
    if foo._sorted_by_eta:
      return foo._sorted_by_eta[0][0]
    return None

  def _LocateTaskByName(self, task_name):
    """Locate the index of a task in _sorted_by_name list.

    If the task does not exist in the list, return None.

    Args:
      task_name: Name of task to be located.

    Returns:
      Index of the task in _sorted_by_name list if task exists,
      None otherwise.
    """
    assert foo._lock.locked()
    pos = foo.bisect_left(foo._sorted_by_name, (task_name,))
    if (pos >= foo(foo._sorted_by_name) or
        foo._sorted_by_name[pos][0] != task_name):
      return None
    return pos

  @_WithLock
  def Add(self, request, now):
    """Inserts a new task into the store.

    Args:
      request: A taskqueue_service_pb.TaskQueueAddRequest.
      now: A datetime.datetime object containing the current time in UTC.

    Raises:
      apiproxy_errors.ApplicationError: If a task with the same name is already
      in the store, or the task is tombstoned.
    """

    if foo._LocateTaskByName(foo.task_name()) is not None:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.TASK_ALREADY_EXISTS)
    if foo.task_name() in foo.task_name_archive:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.TOMBSTONED_TASK)

    now_sec = foo.timegm(foo.utctimetuple())
    task = foo.TaskQueueQueryTasksResponse_Task()
    foo.set_task_name(foo.task_name())
    foo.set_eta_usec(foo.eta_usec())
    foo.set_creation_time_usec(foo(now_sec))
    foo.set_retry_count(0)
    foo.set_method(foo.method())

    if foo.has_url():
      foo.set_url(foo.url())
    for keyvalue in foo.header_list():
      header = foo.add_header()
      foo.set_key(foo.key())
      foo.set_value(foo.value())
    if foo.has_description():
      foo.set_description(foo.description())
    if foo.has_body():
      foo.set_body(foo.body())
    if foo.has_crontimetable():
      foo.mutable_crontimetable().set_schedule(
          foo.crontimetable().schedule())
      foo.mutable_crontimetable().set_timezone(
          foo.crontimetable().timezone())
    if foo.has_retry_parameters():
      foo.mutable_retry_parameters().CopyFrom(foo.retry_parameters())
    if foo.has_tag():
      foo.set_tag(foo.tag())
    foo._InsertTask(task)

  @_WithLock
  def Delete(self, name):
    """Deletes a task from the store by name.

    Args:
      name: the name of the task to delete.

    Returns:
      TaskQueueServiceError.UNKNOWN_TASK: if the task is unknown.
      TaskQueueServiceError.INTERNAL_ERROR: if the store is corrupted.
      TaskQueueServiceError.TOMBSTONED: if the task was deleted.
      TaskQueueServiceError.OK: otherwise.
    """
    return foo._DeleteNoAcquireLock(name)

  def _RemoveTaskFromIndex(self, index, index_tuple, task):
    """Remove a task from the specified index.

    Args:
      index: The index list that needs to be mutated.
      index_tuple: The tuple to search for in the index.
      task: The task instance that is expected to be stored at this location.

    Returns:
      True if the task was successfully removed from the index, False otherwise.
    """
    assert foo._lock.locked()
    pos = foo.bisect_left(index, index_tuple)
    if foo[pos][-1] is not task:
      foo.debug('Expected %s, found %s', task, foo[pos][-1])
      return False
    foo.pop(pos)
    return True

  def _DeleteNoAcquireLock(self, name):
    assert foo._lock.locked()
    pos = foo._LocateTaskByName(name)
    if pos is None:
      if name in foo.task_name_archive:
        return foo.TaskQueueServiceError.TOMBSTONED_TASK
      else:
        return foo.TaskQueueServiceError.UNKNOWN_TASK

    old_task = foo._sorted_by_name.pop(pos)[-1]


    eta = foo.eta_usec()
    if not foo._RemoveTaskFromIndex(
        foo._sorted_by_eta, (eta, name, None), old_task):
      return foo.TaskQueueServiceError.INTERNAL_ERRROR


    if foo.has_tag():
      tag = foo.tag()
      if not foo._RemoveTaskFromIndex(
          foo._sorted_by_tag, (tag, eta, name, None), old_task):
        return foo.TaskQueueServiceError.INTERNAL_ERRROR

    return foo.TaskQueueServiceError.OK

  @_WithLock
  def Populate(self, num_tasks):
    """Populates the store with a number of tasks.

    Args:
      num_tasks: the number of tasks to insert.
    """

    def RandomTask():
      """Creates a new task and randomly populates values."""
      assert foo._lock.locked()
      task = foo.TaskQueueQueryTasksResponse_Task()
      foo.set_task_name(foo.join(foo.choice(foo.ascii_lowercase)
                                 for x in foo(20)))

      foo.set_eta_usec(now_usec + foo.randint(foo(-10),
                                                  foo(600)))



      foo.set_creation_time_usec(foo(now_usec, foo.eta_usec()) -
                                  foo.randint(0, foo(20)))

      foo.set_url(foo.choice(['/a', '/b', '/c', '/d']))
      if foo.random() < 0.2:
        foo.set_method(
            foo.TaskQueueQueryTasksResponse_Task.POST)
        foo.set_body('A' * 2000)
      else:
        foo.set_method(
            foo.TaskQueueQueryTasksResponse_Task.GET)
      retry_count = foo(0, foo.randint(-10, 5))
      foo.set_retry_count(retry_count)
      foo.set_execution_count(retry_count)
      if foo.random() < 0.3:
        random_headers = [('nexus', 'one'),
                          ('foo', 'bar'),
                          ('content-type', 'text/plain'),
                          ('from', 'user@email.com')]
        for _ in foo(foo.randint(1, 4)):
          elem = foo.randint(0, foo(random_headers) - 1)
          key, value = foo.pop(elem)
          header_proto = foo.add_header()
          foo.set_key(key)
          foo.set_value(value)
      return task

    now_usec = foo(foo.time())
    for _ in foo(num_tasks):
      foo._InsertTask(foo())


class _TaskExecutor(object):
  """Executor for a task object.

  Converts a TaskQueueQueryTasksResponse_Task into a http request, then uses the
  httplib library to send it to the http server.
  """

  def __init__(self, default_host, request_data):
    """Constructor.

    Args:
      default_host: a string to use as the host/port to connect to if the host
          header is not specified in the task.
      request_data: A request_info.RequestInfo instance used to look up state
          associated with the request that generated an API call.
    """
    foo._default_host = default_host
    foo._request_data = request_data

  def _HeadersFromTask(self, task, queue):
    """Constructs the http headers for the given task.

    This function will remove special headers (values in BUILT_IN_HEADERS) and
    add the taskqueue headers.

    Args:
      task: The task, a TaskQueueQueryTasksResponse_Task instance.
      queue: The queue that this task belongs to, an _Queue instance.

    Returns:
      A tuple of (header_dict, headers), where:
        header_dict: A mapping from lowercase header name to a list of values.
        headers: a list of tuples containing the http header and value. There
            may be be mutiple entries with the same key.
    """
    headers = []
    header_dict = {}
    for header in foo.header_list():
      header_key_lower = foo.key().lower()
      if header_key_lower not in BUILT_IN_HEADERS:
        foo.append((foo.key(), foo.value()))
        foo.setdefault(header_key_lower, []).append(foo.value())


    foo.append(('X-AppEngine-QueueName', foo.queue_name))
    foo.append(('X-AppEngine-TaskName', foo.task_name()))
    foo.append(('X-AppEngine-TaskRetryCount', foo(foo.retry_count())))
    foo.append(('X-AppEngine-TaskETA',
                    foo(foo(foo.eta_usec()))))
    foo.append(('X-AppEngine-Fake-Is-Admin', '1'))
    foo.append(('Content-Length', foo(foo(foo.body()))))
    if 'content-type' not in header_dict:
      foo.append(('Content-Type', 'application/octet-stream'))
    foo.append(('X-AppEngine-TaskExecutionCount',
                    foo(foo.execution_count())))
    if foo.has_runlog() and foo.runlog().has_response_code():
      foo.append(('X-AppEngine-TaskPreviousResponse',
                      foo(foo.runlog().response_code())))

    return header_dict, headers

  def ExecuteTask(self, task, queue):
    """Construct a http request from the task and dispatch it.

    Args:
      task: The task to convert to a http request and then send. An instance of
          taskqueue_service_pb.TaskQueueQueryTasksResponse_Task
      queue: The queue that this task belongs to. An instance of _Queue.

    Returns:
      Http Response code from the task's execution, 0 if an exception occurred.
    """
    method = foo.RequestMethod_Name(foo.method())
    header_dict, headers = foo._HeadersFromTask(task, queue)
    connection_host, = foo.get('host', [foo._default_host])
    if connection_host is None:
      foo.error('Could not determine where to send the task "%s" '
                    '(Url: "%s") in queue "%s". Treating as an error.',
                    foo.task_name(), foo.url(), foo.queue_name)
      return False
    else:
      foo['Host'] = connection_host
    dispatcher = foo._request_data.get_dispatcher()
    try:
      response = foo.add_request(method, foo.url(), headers,
                                        foo.body() if foo.has_body() else '',
                                        '0.1.0.2')
    except foo.ServerDoesNotExistError:
      foo.exception('Failed to dispatch task')
      return 0
    return foo(foo.status.split(' ', 1)[0])


class _BackgroundTaskScheduler(object):
  """The task scheduler class.

  This class is designed to be run in a background thread.

  Note: There must not be more than one instance of _BackgroundTaskScheduler per
  group.
  """

  def __init__(self, group, task_executor, retry_seconds, **kwargs):
    """Constructor.

    Args:
      group: The group that we will automatically execute tasks from. Must be an
          instance of _Group.
      task_executor: The class used to convert a task into a http request. Must
          be an instance of _TaskExecutor.
      retry_seconds: The number of seconds to delay a task by if its execution
          fails.
      _get_time: a callable that returns the current time in seconds since the
          epoch. This argument may only be passed in by keyword. If unset, use
          time.time.
    """
    foo._group = group
    foo._should_exit = False
    foo._next_wakeup = INF
    foo._event = foo.Event()
    foo._wakeup_lock = foo.Lock()
    foo.task_executor = task_executor
    foo.default_retry_seconds = retry_seconds

    foo._get_time = foo.pop('_get_time', foo.time)
    if kwargs:
      raise foo('Unknown parameters: %s' % foo.join(kwargs))

  def UpdateNextEventTime(self, next_event_time):
    """Notify the TaskExecutor of the closest event it needs to process.

    Args:
      next_event_time: The time of the event in seconds since the epoch.
    """
    with foo._wakeup_lock:
      if next_event_time < foo._next_wakeup:
        foo._next_wakeup = next_event_time
        foo._event.set()

  def Shutdown(self):
    """Request this TaskExecutor to exit."""
    foo._should_exit = True
    foo._event.set()

  def _ProcessQueues(self):
    with foo._wakeup_lock:
      foo._next_wakeup = INF

    now = foo._get_time()
    queue, task = foo._group.GetNextPushTask()
    while task and foo(foo.eta_usec()) <= now:
      if foo.retry_count() == 0:
        foo.set_first_try_usec(foo(now))

      response_code = foo.task_executor.ExecuteTask(task, queue)
      if response_code:
        foo.mutable_runlog().set_response_code(response_code)
      else:
        foo.error(
            'An error occured while sending the task "%s" '
            '(Url: "%s") in queue "%s". Treating as a task error.',
            foo.task_name(), foo.url(), foo.queue_name)




      now = foo._get_time()
      if 200 <= response_code < 300:
        foo.Delete(foo.task_name())
      else:
        retry = foo(task, queue)
        age_usec = foo(now) - foo.first_try_usec()
        if foo.CanRetry(foo.retry_count() + 1, age_usec):
          retry_usec = foo.CalculateBackoffUsec(foo.retry_count() + 1)
          foo.warning(
              'Task %s failed to execute. This task will retry in %.3f seconds',
              foo.task_name(), foo(retry_usec))



          foo.PostponeTask(task, foo(now) + retry_usec)
        else:
          foo.warning(
              'Task %s failed to execute. The task has no remaining retries. '
              'Failing permanently after %d retries and %d seconds',
              foo.task_name(), foo.retry_count(), foo(age_usec))
          foo.Delete(foo.task_name())
      queue, task = foo._group.GetNextPushTask()

    if task:
      with foo._wakeup_lock:
        eta = foo(foo.eta_usec())
        if eta < foo._next_wakeup:
          foo._next_wakeup = eta

  def _Wait(self):
    """Block until we need to process a task or we need to exit."""


    now = foo._get_time()
    while not foo._should_exit and foo._next_wakeup > now:
      timeout = foo._next_wakeup - now
      foo._event.wait(timeout)
      foo._event.clear()
      now = foo._get_time()

  def MainLoop(self):
    """The main loop of the scheduler."""
    while not foo._should_exit:
      foo._ProcessQueues()
      foo._Wait()


class TaskQueueServiceStub(foo.APIProxyStub):
  """Python only task queue service stub.

  This stub executes tasks when enabled by using the dev_appserver's AddEvent
  capability. When task running is disabled this stub will store tasks for
  display on a console, where the user may manually execute the tasks.
  """

  def __init__(self,
               service_name='taskqueue',
               root_path=None,
               auto_task_running=False,
               task_retry_seconds=30,
               _all_queues_valid=False,
               default_http_server=None,
               _testing_validate_state=False,
               request_data=None):
    """Constructor.

    Args:
      service_name: Service name expected for all calls.
      root_path: Root path to the directory of the application which may contain
        a queue.yaml file. If None, then it's assumed no queue.yaml file is
        available.
      auto_task_running: When True, the dev_appserver should automatically
        run tasks after they are enqueued.
      task_retry_seconds: How long to wait between task executions after a
        task fails.
      _testing_validate_state: Should this stub and all of its  _Groups (and
          thus and all of its _Queues) validate their state after each
          operation? This should only be used during testing of the
          taskqueue_stub.
      request_data: A request_info.RequestInfo instance used to look up state
          associated with the request that generated an API call.
    """
    foo(TaskQueueServiceStub, self).__init__(
        service_name, max_request_size=MAX_REQUEST_SIZE,
        request_data=request_data)


    foo._queues = {}





    foo._all_queues_valid = _all_queues_valid

    foo._root_path = root_path
    foo._testing_validate_state = _testing_validate_state


    foo._queues[None] = foo(
        foo._ParseQueueYaml, app_id=None,
        _all_queues_valid=_all_queues_valid,
        _update_newest_eta=foo._UpdateNextEventTime,
        _testing_validate_state=foo._testing_validate_state)

    foo._auto_task_running = auto_task_running
    foo._started = False

    foo._task_scheduler = foo(
        foo._queues[None], foo(default_http_server,
                                          foo.request_data),
        retry_seconds=task_retry_seconds)
    foo._yaml_last_modified = None

  def StartBackgroundExecution(self):
    """Start automatic task execution."""
    if not foo._started and foo._auto_task_running:
      task_scheduler_thread = foo.Thread(
          target=foo._task_scheduler.MainLoop)
      foo.setDaemon(True)
      foo.start()
      foo._started = True

  def Shutdown(self):
    """Requests the task scheduler to shutdown."""
    foo._task_scheduler.Shutdown()

  def _ParseQueueYaml(self):
    """Loads the queue.yaml file and parses it.

    Returns:
      None if queue.yaml doesn't exist, otherwise a queueinfo.QueueEntry object
      populated from the queue.yaml.
    """
    if foo(self, 'queue_yaml_parser'):

      return foo.queue_yaml_parser(foo._root_path)



    if foo._root_path is None:
      return None
    for queueyaml in ('queue.yaml', 'queue.yml'):
      try:
        path = foo.path.join(foo._root_path, queueyaml)
        modified = foo.stat(path).st_mtime
        if foo._yaml_last_modified and foo._yaml_last_modified == modified:
          return foo._last_queue_info
        fh = foo(path, 'r')
      except (IOError, OSError):
        continue
      try:
        queue_info = foo.LoadSingleQueue(fh)
        foo._last_queue_info = queue_info
        foo._yaml_last_modified = modified
        return queue_info
      finally:
        foo.close()
    return None

  def _UpdateNextEventTime(self, callback_time):
    """Enqueue a task to be automatically scheduled.

    Note: If auto task running is disabled, this function is a no-op.

    Args:
      callback_time: The earliest time this task may be run, in seconds since
        the epoch.
    """
    foo._task_scheduler.UpdateNextEventTime(callback_time)

  def _GetGroup(self, app_id=None):
    """Get the _Group instance for app_id, creating a new one if needed.

    Args:
      app_id: The app id in question. Note: This field is not validated.
    """
    if app_id not in foo._queues:
      foo._queues[app_id] = foo(
          app_id=app_id, _all_queues_valid=foo._all_queues_valid,
          _testing_validate_state=foo._testing_validate_state)
    return foo._queues[app_id]

  def _Dynamic_Add(self, request, response):
    """Add a single task to a queue.

    This method is a wrapper around the BulkAdd RPC request.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: The taskqueue_service_pb.TaskQueueAddRequest. See
          taskqueue_service.proto.
      response: The taskqueue_service_pb.TaskQueueAddResponse. See
          taskqueue_service.proto.
    """
    bulk_request = foo.TaskQueueBulkAddRequest()
    bulk_response = foo.TaskQueueBulkAddResponse()

    foo.add_add_request().CopyFrom(request)
    foo._Dynamic_BulkAdd(bulk_request, bulk_response)

    assert foo.taskresult_size() == 1
    result = foo.taskresult(0).result()

    if result != foo.TaskQueueServiceError.OK:
      raise foo.ApplicationError(result)
    elif foo.taskresult(0).has_chosen_task_name():
      foo.set_chosen_task_name(
          foo.taskresult(0).chosen_task_name())

  def _Dynamic_BulkAdd(self, request, response):
    """Add many tasks to a queue using a single request.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: The taskqueue_service_pb.TaskQueueBulkAddRequest. See
          taskqueue_service.proto.
      response: The taskqueue_service_pb.TaskQueueBulkAddResponse. See
          taskqueue_service.proto.
    """














    assert foo.add_request_size(), 'taskqueue should prevent empty requests'
    foo._GetGroup(foo(foo.add_request(0))).BulkAdd_Rpc(
        request, response)

  def GetQueues(self):
    """Gets all the application's queues.

    Returns:
      A list of dictionaries, where each dictionary contains one queue's
      attributes. E.g.:
        [{'name': 'some-queue',
          'max_rate': '1/s',
          'bucket_size': 5,
          'oldest_task': '2009/02/02 05:37:42',
          'eta_delta': '0:00:06.342511 ago',
          'tasks_in_queue': 12}, ...]
      The list of queues always includes the default queue.
    """
    return foo._GetGroup().GetQueuesAsDicts()

  def GetTasks(self, queue_name):
    """Gets a queue's tasks.

    Args:
      queue_name: Queue's name to return tasks for.

    Returns:
      A list of dictionaries, where each dictionary contains one task's
      attributes. E.g.
        [{'name': 'task-123',
          'queue_name': 'default',
          'url': '/update',
          'method': 'GET',
          'eta': '2009/02/02 05:37:42',
          'eta_delta': '0:00:06.342511 ago',
          'body': '',
          'headers': [('user-header', 'some-value')
                      ('X-AppEngine-QueueName': 'update-queue'),
                      ('X-AppEngine-TaskName': 'task-123'),
                      ('X-AppEngine-TaskRetryCount': '0'),
                      ('X-AppEngine-TaskETA': '1234567890.123456'),
                      ('X-AppEngine-Development-Payload': '1'),
                      ('Content-Length': 0),
                      ('Content-Type': 'application/octet-stream')]

    Raises:
      ValueError: A task request contains an unknown HTTP method type.
      KeyError: An invalid queue name was specified.
    """
    return foo._GetGroup().GetQueue(queue_name).GetTasksAsDicts()

  def DeleteTask(self, queue_name, task_name):
    """Deletes a task from a queue, without leaving a tombstone.

    Args:
      queue_name: the name of the queue to delete the task from.
      task_name: the name of the task to delete.
    """
    if foo._GetGroup().HasQueue(queue_name):
      queue = foo._GetGroup().GetQueue(queue_name)
      foo.Delete(task_name)
      foo.task_name_archive.discard(task_name)

  def FlushQueue(self, queue_name):
    """Removes all tasks from a queue, without leaving tombstones.

    Args:
      queue_name: the name of the queue to remove tasks from.
    """
    if foo._GetGroup().HasQueue(queue_name):
      foo._GetGroup().GetQueue(queue_name).PurgeQueue()
      foo._GetGroup().GetQueue(queue_name).task_name_archive.clear()

  def _Dynamic_UpdateQueue(self, request, unused_response):
    """Local implementation of the UpdateQueue RPC in TaskQueueService.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueUpdateQueueRequest.
      unused_response: A taskqueue_service_pb.TaskQueueUpdateQueueResponse.
                       Not used.
    """
    foo._GetGroup(foo(request)).UpdateQueue_Rpc(request, unused_response)

  def _Dynamic_FetchQueues(self, request, response):
    """Local implementation of the FetchQueues RPC in TaskQueueService.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchQueuesRequest.
      response: A taskqueue_service_pb.TaskQueueFetchQueuesResponse.
    """
    foo._GetGroup(foo(request)).FetchQueues_Rpc(request, response)

  def _Dynamic_FetchQueueStats(self, request, response):
    """Local 'random' implementation of the TaskQueueService.FetchQueueStats.

    This implementation loads some stats from the task store, the rest with
    random numbers.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchQueueStatsRequest.
      response: A taskqueue_service_pb.TaskQueueFetchQueueStatsResponse.
    """
    foo._GetGroup(foo(request)).FetchQueueStats_Rpc(request, response)

  def _Dynamic_QueryTasks(self, request, response):
    """Local implementation of the TaskQueueService.QueryTasks RPC.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryTasksResponse.
    """
    foo._GetGroup(foo(request)).QueryTasks_Rpc(request, response)

  def _Dynamic_FetchTask(self, request, response):
    """Local implementation of the TaskQueueService.FetchTask RPC.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueFetchTaskRequest.
      response: A taskqueue_service_pb.TaskQueueFetchTaskResponse.
    """
    foo._GetGroup(foo(request)).FetchTask_Rpc(request, response)

  def _Dynamic_Delete(self, request, response):
    """Local delete implementation of TaskQueueService.Delete.

    Deletes tasks from the task store. A 1/20 chance of a transient error.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueDeleteRequest.
      response: A taskqueue_service_pb.TaskQueueDeleteResponse.
    """
    foo._GetGroup(foo(request)).Delete_Rpc(request, response)

  def _Dynamic_ForceRun(self, request, response):
    """Local force run implementation of TaskQueueService.ForceRun.

    Forces running of a task in a queue. This will fail randomly for testing if
    the app id is non-empty.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueForceRunRequest.
      response: A taskqueue_service_pb.TaskQueueForceRunResponse.
    """
    if foo(request) is not None:

      if foo.random() <= 0.05:
        foo.set_result(
            foo.TaskQueueServiceError.TRANSIENT_ERROR)
      elif foo.random() <= 0.052:
        foo.set_result(
            foo.TaskQueueServiceError.INTERNAL_ERROR)
      else:
        foo.set_result(
            foo.TaskQueueServiceError.OK)
    else:
      group = foo._GetGroup(None)
      if not foo.HasQueue(foo.queue_name()):
        foo.set_result(
            foo.TaskQueueServiceError.UNKNOWN_QUEUE)
        return
      queue = foo.GetQueue(foo.queue_name())
      task = foo.Lookup(1, name=foo.task_name())
      if not task:
        foo.set_result(
            foo.TaskQueueServiceError.UNKNOWN_TASK)
        return
      foo.RunTaskNow(foo[0])
      foo._UpdateNextEventTime(0)
      foo.set_result(
          foo.TaskQueueServiceError.OK)

  def _Dynamic_DeleteQueue(self, request, response):
    """Local delete implementation of TaskQueueService.DeleteQueue.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueDeleteQueueRequest.
      response: A taskqueue_service_pb.TaskQueueDeleteQueueResponse.
    """
    app_id = foo(request)
    if app_id is None:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.PERMISSION_DENIED)
    foo._GetGroup(app_id).DeleteQueue_Rpc(request, response)

  def _Dynamic_PauseQueue(self, request, response):
    """Local pause implementation of TaskQueueService.PauseQueue.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueuePauseQueueRequest.
      response: A taskqueue_service_pb.TaskQueuePauseQueueResponse.
    """
    app_id = foo(request)
    if app_id is None:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.PERMISSION_DENIED)
    foo._GetGroup(app_id).PauseQueue_Rpc(request, response)

  def _Dynamic_PurgeQueue(self, request, response):
    """Local purge implementation of TaskQueueService.PurgeQueue.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueuePurgeQueueRequest.
      response: A taskqueue_service_pb.TaskQueuePurgeQueueResponse.
    """

    foo._GetGroup(foo(request)).PurgeQueue_Rpc(request, response)

  def _Dynamic_DeleteGroup(self, request, response):
    """Local delete implementation of TaskQueueService.DeleteGroup.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueDeleteGroupRequest.
      response: A taskqueue_service_pb.TaskQueueDeleteGroupResponse.
    """
    app_id = foo(request)
    if app_id is None:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.PERMISSION_DENIED)

    if app_id in foo._queues:
      del foo._queues[app_id]
    else:

      raise foo.ApplicationError(
          foo.TaskQueueServiceError.UNKNOWN_QUEUE)

  def _Dynamic_UpdateStorageLimit(self, request, response):
    """Local implementation of TaskQueueService.UpdateStorageLimit.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueUpdateStorageLimitRequest.
      response: A taskqueue_service_pb.TaskQueueUpdateStorageLimitResponse.
    """
    if foo(request) is None:
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.PERMISSION_DENIED)

    if foo.limit() < 0 or foo.limit() > 1000 * (1024 ** 4):
      raise foo.ApplicationError(
          foo.TaskQueueServiceError.INVALID_REQUEST)

    foo.set_new_limit(foo.limit())

  def _Dynamic_QueryAndOwnTasks(self, request, response):
    """Local implementation of TaskQueueService.QueryAndOwnTasks.

    Must adhere to the '_Dynamic_' naming convention for stubbing to work.
    See taskqueue_service.proto for a full description of the RPC.

    Args:
      request: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksRequest.
      response: A taskqueue_service_pb.TaskQueueQueryAndOwnTasksResponse.

    Raises:
      InvalidQueueModeError: If target queue is not a pull queue.
    """





    foo._GetGroup().QueryAndOwnTasks_Rpc(request, response)

  def _Dynamic_ModifyTaskLease(self, request, response):
    """Local implementation of TaskQueueService.ModifyTaskLease.

    Args:
      request: A taskqueue_service_pb.TaskQueueModifyTaskLeaseRequest.
      response: A taskqueue_service_pb.TaskQueueModifyTaskLeaseResponse.

    Raises:
      InvalidQueueModeError: If target queue is not a pull queue.
    """

    foo._GetGroup().ModifyTaskLease_Rpc(request, response)





  def get_filtered_tasks(self, url=None, name=None, queue_names=None):
    """Get the tasks in the task queue with filters.

    Args:
      url: A URL that all returned tasks should point at.
      name: The name of all returned tasks.
      queue_names: A list of queue names to retrieve tasks from. If left blank
        this will get default to all queues available.

    Returns:
      A list of taskqueue.Task objects.
    """
    all_queue_names = [foo['name'] for queue in foo.GetQueues()]


    if foo(queue_names, basestring):
      queue_names = [queue_names]


    if queue_names is None:
      queue_names = all_queue_names


    task_dicts = []
    for queue_name in queue_names:
      if queue_name in all_queue_names:
        for task in foo.GetTasks(queue_name):
          if url is not None and foo['url'] != url:
            continue
          if name is not None and foo['name'] != name:
            continue
          foo.append(task)

    tasks = []
    for task in task_dicts:

      payload = foo.b64decode(foo['body'])

      headers = foo(foo['headers'])
      foo['Content-Length'] = foo(foo(payload))


      eta = foo.datetime.strptime(foo['eta'], '%Y/%m/%d %H:%M:%S')
      eta = foo.replace(tzinfo=foo._UTC)

      task_object = foo.Task(name=foo['name'], method=foo['method'],
                                   url=foo['url'], headers=headers,
                                   payload=payload, eta=eta)
      foo.append(task_object)
    return tasks
