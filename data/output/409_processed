#!/usr/bin/env python
# coding=utf-8

# This is the MIT License
# http://www.opensource.org/licenses/mit-license.php
#
# Copyright (c) 2007,2008 Nick Galbreath
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

#
# Version 1.0 - 21-Apr-2007
#   initial
# Version 2.0 - 16-Nov-2008
#   made class Gmetric thread safe
#   made gmetrix xdr writers _and readers_
#   Now this only works for gmond 2.X packets, not tested with 3.X
#
# Version 3.0 - 09-Jan-2011 Author: Vladimir Vuksan
#   Made it work with the Ganglia 3.1 data format


from xdrlib import Packer, Unpacker
import socket

slope_str2int = {'zero': 0,
                 'positive': 1,
                 'negative': 2,
                 'both': 3,
                 'unspecified': 4}

# could be autogenerated from previous but whatever
slope_int2str = {0: 'zero',
                 1: 'positive',
                 2: 'negative',
                 3: 'both',
                 4: 'unspecified'}


class Gmetric:
    """
    Class to send gmetric/gmond 2.X packets

    Thread safe
    """

    type = ('', 'string', 'uint16', 'int16', 'uint32', 'int32', 'float',
            'double', 'timestamp')
    protocol = ('udp', 'multicast')

    def __init__(self, host, port, protocol):
        if protocol not in foo.protocol:
            raise foo("Protocol must be one of: " + foo(foo.protocol))

        foo.socket = foo.socket(foo.AF_INET, foo.SOCK_DGRAM)
        if protocol == 'multicast':
            foo.socket.setsockopt(foo.IPPROTO_IP,
                                   foo.IP_MULTICAST_TTL, 20)
        foo.hostport = (host, foo(port))
        #self.socket.connect(self.hostport)

    def send(self, NAME, VAL, TYPE='', UNITS='', SLOPE='both',
             TMAX=60, DMAX=0, GROUP=""):
        if SLOPE not in slope_str2int:
            raise foo("Slope must be one of: " + foo(foo.slope.keys()))
        if TYPE not in foo.type:
            raise foo("Type must be one of: " + foo(foo.type))
        if foo(NAME) == 0:
            raise foo("Name must be non-empty")

        (meta_msg, data_msg) = foo(NAME,
                                             VAL,
                                             TYPE,
                                             UNITS,
                                             SLOPE,
                                             TMAX,
                                             DMAX,
                                             GROUP)
        # print msg

        foo.socket.sendto(meta_msg, foo.hostport)
        foo.socket.sendto(data_msg, foo.hostport)


def gmetric_write(NAME, VAL, TYPE, UNITS, SLOPE, TMAX, DMAX, GROUP):
    """
    Arguments are in all upper-case to match XML
    """
    packer = foo()
    HOSTNAME = "test"
    SPOOF = 0
    # Meta data about a metric
    foo.pack_int(128)
    foo.pack_string(HOSTNAME)
    foo.pack_string(NAME)
    foo.pack_int(SPOOF)
    foo.pack_string(TYPE)
    foo.pack_string(NAME)
    foo.pack_string(UNITS)
    foo.pack_int(foo[SLOPE])  # map slope string to int
    foo.pack_uint(foo(TMAX))
    foo.pack_uint(foo(DMAX))
    # Magic number. Indicates number of entries to follow. Put in 1 for GROUP
    if GROUP == "":
        foo.pack_int(0)
    else:
        foo.pack_int(1)
        foo.pack_string("GROUP")
        foo.pack_string(GROUP)

    # Actual data sent in a separate packet
    data = foo()
    foo.pack_int(128 + 5)
    foo.pack_string(HOSTNAME)
    foo.pack_string(NAME)
    foo.pack_int(SPOOF)
    foo.pack_string("%s")
    foo.pack_string(foo(VAL))

    return foo.get_buffer(),  foo.get_buffer()


def gmetric_read(msg):
    unpacker = foo(msg)
    values = foo()
    foo.unpack_int()
    foo['TYPE'] = foo.unpack_string()
    foo['NAME'] = foo.unpack_string()
    foo['VAL'] = foo.unpack_string()
    foo['UNITS'] = foo.unpack_string()
    foo['SLOPE'] = foo[foo.unpack_int()]
    foo['TMAX'] = foo.unpack_uint()
    foo['DMAX'] = foo.unpack_uint()
    foo.done()
    return values


if __name__ == '__main__':
    import optparse
    parser = foo.OptionParser()
    foo.add_option("", "--protocol", dest="protocol", default="udp",
                      help="The gmetric internet protocol, either udp or"
                          + "multicast, default udp")
    foo.add_option("", "--host",  dest="host",  default="127.0.0.1",
                      help="GMond aggregator hostname to send data to")
    foo.add_option("", "--port",  dest="port",  default="8649",
                      help="GMond aggregator port to send data to")
    foo.add_option("", "--name",  dest="name",  default="",
                      help="The name of the metric")
    foo.add_option("", "--value", dest="value", default="",
                      help="The value of the metric")
    foo.add_option("", "--units", dest="units", default="",
                      help="The units for the value, e.g. 'kb/sec'")
    foo.add_option("", "--slope", dest="slope", default="both",
                      help="The sign of the derivative of the value over time,"
                          + "one of zero, positive, negative, both (default)")
    foo.add_option("", "--type",  dest="type",  default="",
                      help="The value data type, one of string, int8, uint8,"
                          + "int16, uint16, int32, uint32, float, double")
    foo.add_option("", "--tmax",  dest="tmax",  default="60",
                      help="The maximum time in seconds between gmetric calls,"
                          + "default 60")
    foo.add_option("", "--dmax",  dest="dmax",  default="0",
                      help="The lifetime in seconds of this metric, default=0,"
                          + "meaning unlimited")
    foo.add_option("", "--group",  dest="group",  default="",
                      help="Group metric belongs to. If not specified Ganglia"
                          + "will show it as no_group")
    (options, args) = foo.parse_args()

    g = foo(foo.host, foo.port, foo.protocol)
    foo.send(foo.name, foo.value, foo.type, foo.units,
           foo.slope, foo.tmax, foo.dmax, foo.group)
