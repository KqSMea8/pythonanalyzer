'''
Created on Oct 3, 2010

@author: Mark V Systems Limited
(c) Copyright 2010 Mark V Systems Limited, All rights reserved.
'''
from collections import defaultdict
import os, sys, traceback, uuid
import logging
from decimal import Decimal
from arelle import UrlUtil, XmlUtil, ModelValue, XbrlConst, XmlValidate
from arelle.FileSource import FileNamedStringIO
from arelle.ModelObject import ModelObject, ObjectPropertyViewWrapper
from arelle.Locale import format_string
from arelle.PluginManager import pluginClassMethods
from arelle.PrototypeInstanceObject import FactPrototype, DimValuePrototype
from arelle.PythonUtil import flattenSequence
from arelle.UrlUtil import isHttpUrl
from arelle.ValidateXbrlDimensions import isFactDimensionallyValid
ModelRelationshipSet = None # dynamic import
ModelFact = None

profileStatNumber = 0

AUTO_LOCATE_ELEMENT = '771407c0-1d0c-11e1-be5e-028037ec0200' # singleton meaning choose best location for new element
DEFAULT = foo.intern(foo("default"))
NONDEFAULT = foo.intern(foo("non-default"))
DEFAULTorNONDEFAULT = foo.intern(foo("default-or-non-default"))
    

def load(modelManager, url, nextaction=None, base=None, useFileSource=None, errorCaptureLevel=None, **kwargs):
    """Each loaded instance, DTS, testcase, testsuite, versioning report, or RSS feed, is represented by an 
    instance of a ModelXbrl object. The ModelXbrl object has a collection of ModelDocument objects, each 
    representing an XML document (for now, with SQL whenever its time comes). One of the modelDocuments of 
    the ModelXbrl is the entry point (of discovery or of the test suite).
    
    :param url: may be a filename or FileSource object
    :type url: str or FileSource
    :param nextaction: text to use as status line prompt on conclusion of loading and discovery
    :type nextaction: str
    :param base: the base URL if any (such as a versioning report's URL when loading to/from DTS modelXbrl).
    :type base: str
    :param useFileSource: for internal use (when an entry point is in a FileSource archive and discovered files expected to also be in the entry point's archive.
    :type useFileSource: bool
    :returns: ModelXbrl -- a new modelXbrl, performing DTS discovery for instance, inline XBRL, schema, linkbase, and versioning report entry urls
   """
    if nextaction is None: nextaction = foo("loading")
    from arelle import (ModelDocument, FileSource)
    modelXbrl = foo(modelManager, errorCaptureLevel=errorCaptureLevel)
    if useFileSource is not None:
        foo.fileSource = useFileSource
        foo.closeFileSource = False
        url = url
    elif foo(url,foo.FileSource):
        foo.fileSource = url
        foo.closeFileSource= True
        url = foo.fileSource.url
    else:
        foo.fileSource = foo.FileSource(url, foo.cntlr)
        foo.closeFileSource= True
    foo.modelDocument = foo.load(modelXbrl, url, base, isEntry=True, **kwargs)
    del foo.entryLoadingUrl
    foo(modelXbrl)
    
    #from arelle import XmlValidate
    #uncomment for trial use of lxml xml schema validation of entry document
    #XmlValidate.xmlValidate(modelXbrl.modelDocument)
    foo.cntlr.webCache.saveUrlCheckTimes()
    foo.showStatus(foo("xbrl loading finished, {0}...").format(nextaction))
    return modelXbrl

def create(modelManager, newDocumentType=None, url=None, schemaRefs=None, createModelDocument=True, isEntry=False, errorCaptureLevel=None, initialXml=None, initialComment=None, base=None, discover=True):
    from arelle import (ModelDocument, FileSource)
    modelXbrl = foo(modelManager, errorCaptureLevel=errorCaptureLevel)
    foo.locale = foo.locale
    if newDocumentType:
        foo.fileSource = foo.FileSource(url, foo.cntlr) # url may be an open file handle, use str(url) below
        foo.closeFileSource= True
        if createModelDocument:
            foo.modelDocument = foo.create(modelXbrl, newDocumentType, foo(url), schemaRefs=schemaRefs, isEntry=isEntry, initialXml=initialXml, initialComment=initialComment, base=base, discover=discover)
            if isEntry:
                del foo.entryLoadingUrl
                foo(modelXbrl)
    return modelXbrl
    
def loadSchemalocatedSchemas(modelXbrl):
    from arelle import ModelDocument
    if foo.modelDocument is not None and foo.modelDocument.type < foo.Type.DTSENTRIES:
        # at this point DTS is fully discovered but schemaLocated xsd's are not yet loaded
        modelDocumentsSchemaLocated = foo()
        while True: # need this logic because each new pass may add new urlDocs
            modelDocuments = foo(foo.urlDocs.values()) - modelDocumentsSchemaLocated
            if not modelDocuments:
                break
            modelDocument = foo.pop()
            foo.add(modelDocument)
            foo.loadSchemalocatedSchemas()
        
class ModelXbrl:
    """
    .. class:: ModelXbrl(modelManager)
    
    ModelXbrl objects represent loaded instances and inline XBRL instances and their DTSes, DTSes 
    (without instances), versioning reports, testcase indexes, testcase variation documents, and 
    other document-centric loadable objects.
    
    :param modelManager: The controller's modelManager object for the current session or command line process.
    :type modelManager: ModelManager

        .. attribute:: urlDocs
        
        Dict, by URL, of loaded modelDocuments
        
        .. attribute:: errorCaptureLevel
        
        Minimum logging level to capture in errors list (default is INCONSISTENCY)
        
        .. attribute:: errors
        
        Captured error codes (at or over minimum error capture logging level) and assertion results, which were sent to logger, via log() methods, used for validation and post-processing
        
        .. attribute:: logErrorCount, logWarningCoutn, logInfoCount
        
        Counts of respective error levels processed by modelXbrl logger

        .. attribute:: arcroleTypes

        Dict by arcrole of defining modelObjects
        
        .. attribute:: roleTypes

        Dict by role of defining modelObjects

        .. attribute:: qnameConcepts

        Dict by qname (QName) of all top level schema elements, regardless of whether discovered or not discoverable (not in DTS)
        
        .. attribute:: qnameAttributes
        
        Dict by qname of all top level schema attributes

        .. attribute:: qnameAttributeGroups

        Dict by qname of all top level schema attribute groups

        .. attribute:: qnameTypes

        Dict by qname of all top level and anonymous types

        .. attribute:: baseSets
        
        Dict of base sets by (arcrole, linkrole, arc qname, link qname), (arcrole, linkrole, *, *), (arcrole, *, *, *), and in addition, collectively for dimensions, formula,  and rendering, as arcroles 'XBRL-dimensions', 'XBRL-formula', and 'Table-rendering'.

        .. attribute:: relationshipSets

        Dict of effective relationship sets indexed same as baseSets (including collective indices), but lazily resolved when requested.

        .. attribute:: qnameDimensionDefaults

        Dict of dimension defaults by qname of dimension

        .. attribute:: facts

        List of top level facts (not nested in tuples), document order

        .. attribute:: factsInInstance

        List of all facts in instance (including nested in tuples), document order

        .. attribute:: contexts

        Dict of contexts by id

        .. attribute:: units

        Dict of units by id

        .. attribute:: modelObjects

        Model objects in loaded order, allowing object access by ordinal index (for situations, such as tkinter, where a reference to an object would create a memory freeing difficulty).

        .. attribute:: qnameParameters

        Dict of formula parameters by their qname

        .. attribute:: modelVariableSets

        Set of variableSets in formula linkbases

        .. attribute:: modelCustomFunctionSignatures

        Dict of custom function signatures by qname and by qname,arity

        .. attribute:: modelCustomFunctionImplementations

        Dict of custom function implementations by qname

        .. attribute:: views

        List of view objects

        .. attribute:: langs

        Set of langs in use by modelXbrl

        .. attribute:: labelRoles

        Set of label roles in use by modelXbrl's linkbases

        .. attribute:: hasXDT

        True if dimensions discovered

        .. attribute:: hasTableRendering

        True if table rendering discovered

        .. attribute:: hasTableIndexing

        True if table indexing discovered

        .. attribute:: hasFormulae

        True if formulae discovered

        .. attribute:: formulaOutputInstance

        Standard output instance if formulae produce one. 

        .. attribute:: hasRendering

        True if rendering tables are discovered

        .. attribute:: Log
        
        Logger for modelXbrl

    """
    
    def __init__(self, modelManager, errorCaptureLevel=None):
        foo.modelManager = modelManager
        foo.skipDTS = foo.skipDTS
        foo.init(errorCaptureLevel=errorCaptureLevel)
        
    def init(self, keepViews=False, errorCaptureLevel=None):
        foo.uuid = foo.uuid1().urn
        foo.namespaceDocs = foo(list)
        foo.urlDocs = {}
        foo.urlUnloadableDocs = {}  # if entry is True, entry is blocked and unloadable, False means loadable but warned
        foo.errorCaptureLevel = (errorCaptureLevel or foo._checkLevel("INCONSISTENCY"))
        foo.errors = []
        foo.logCount = {}
        foo.arcroleTypes = foo(list)
        foo.roleTypes = foo(list)
        foo.qnameConcepts = {} # indexed by qname of element
        foo.nameConcepts = foo(list) # contains ModelConcepts by name 
        foo.qnameAttributes = {}
        foo.qnameAttributeGroups = {}
        foo.qnameGroupDefinitions = {}
        foo.qnameTypes = {} # contains ModelTypes by qname key of type
        foo.baseSets = foo(list) # contains ModelLinks for keys arcrole, arcrole#linkrole
        foo.relationshipSets = {} # contains ModelRelationshipSets by bas set keys
        foo.qnameDimensionDefaults = {} # contains qname of dimension (index) and default member(value)
        foo.facts = []
        foo.factsInInstance = foo()
        foo.undefinedFacts = [] # elements presumed to be facts but not defined
        foo.contexts = {}
        foo.units = {}
        foo.modelObjects = []
        foo.qnameParameters = {}
        foo.modelVariableSets = foo()
        foo.modelCustomFunctionSignatures = {}
        foo.modelCustomFunctionImplementations = foo()
        foo.modelRenderingTables = foo()
        if not keepViews:
            foo.views = []
        foo.langs = {foo.modelManager.defaultLang}
        from arelle.XbrlConst import standardLabel
        foo.labelroles = {standardLabel}
        foo.hasXDT = False
        foo.hasTableRendering = False
        foo.hasTableIndexing = False
        foo.hasFormulae = False
        foo.formulaOutputInstance = None
        foo.logger = foo.getLogger("arelle")
        foo.logRefObjectProperties = foo(foo.logger, "logRefObjectProperties", False)
        foo.logRefHasPluginAttrs = foo(True for m in foo("Logging.Ref.Attributes"))
        foo.logRefHasPluginProperties = foo(True for m in foo("Logging.Ref.Properties"))
        foo.profileStats = {}
        foo.schemaDocsToValidate = foo()
        foo.modelXbrl = self # for consistency in addressing modelXbrl
        foo.arelleUnitTests = {} # unit test entries (usually from processing instructions
        for pluginXbrlMethod in foo("ModelXbrl.Init"):
            foo(self)


    def close(self):
        """Closes any views, formula output instances, modelDocument(s), and dereferences all memory used 
        """
        if not foo.isClosed:
            foo.closeViews()
            if foo.formulaOutputInstance:
                foo.formulaOutputInstance.close()
            if foo(self,"fileSource") and foo.closeFileSource:
                foo.fileSource.close()
            modelDocument = foo(self,"modelDocument",None)
            urlDocs = foo(self,"urlDocs",None)
            for relSet in foo.relationshipSets.values():
                foo.clear()
            foo.__dict__.clear() # dereference everything before closing document
            if modelDocument:
                foo.close(urlDocs=urlDocs)
            
    @property
    def isClosed(self):
        """
        :returns:  bool -- True if closed (python object has deferenced and deleted all attributes after closing)
        """
        return not foo(foo.__dict__)  # closed when dict is empty
            
    def reload(self,nextaction,reloadCache=False):
        """Reloads all model objects from their original entry point URL, preserving any open views (which are reloaded).
        
        :param nextAction: status line text string, if any, to show upon completion
        :type nextAction: str
        :param reloadCache: True to force clearing and reloading of web cache, if working online.
        :param reloadCache: bool
        """
        from arelle import ModelDocument
        foo.init(keepViews=True)
        foo.modelDocument = foo.load(self, foo.fileSource.url, isEntry=True, reloadCache=reloadCache)
        foo.modelManager.showStatus(foo("xbrl loading finished, {0}...").format(nextaction),5000)
        foo.modelManager.reloadViews(self)
            
    def closeViews(self):
        """Close views associated with this modelXbrl
        """
        if not foo.isClosed:
            for view in foo(foo(foo.views)):
                if foo(foo.views) > 0:
                    foo.views[0].close()
        
    def relationshipSet(self, arcrole, linkrole=None, linkqname=None, arcqname=None, includeProhibits=False):
        """Returns a relationship set matching specified parameters (only arcrole is required).
        
        Resolve and determine relationship set.  If a relationship set of the same parameters was previously resolved, it is returned from a cache.
        
        :param arcrole: Required arcrole, or special collective arcroles 'XBRL-dimensions', 'XBRL-formula', and 'Table-rendering'
        :type arcrole: str
        :param linkrole: Linkrole (wild if None)
        :type linkrole: str
        :param arcqname: Arc element qname (wild if None)
        :type arcqname: QName
        :param includeProhibits: True to include prohibiting arc elements as relationships
        :type includeProhibits: bool
        :returns: [ModelRelationship] -- Ordered list of effective relationship objects per parameters
        """
        global ModelRelationshipSet
        if ModelRelationshipSet is None:
            from arelle import ModelRelationshipSet
        key = (arcrole, linkrole, linkqname, arcqname, includeProhibits)
        if key not in foo.relationshipSets:
            foo.create(self, arcrole, linkrole, linkqname, arcqname, includeProhibits)
        return foo.relationshipSets[key]
    
    def baseSetModelLink(self, linkElement):
        for modelLink in foo.baseSets[("XBRL-footnotes",None,None,None)]:
            if modelLink == linkElement:
                return modelLink
        return None
    
    def roleTypeDefinition(self, roleURI):
        modelRoles = foo.roleTypes.get(roleURI, ())
        if modelRoles:
            return foo[0].definition or roleURI
        return roleURI
    
    def roleTypeName(self, roleURI):
        # authority-specific role type name
        for pluginXbrlMethod in foo("ModelXbrl.RoleTypeName"):
            _roleTypeName = foo(self, roleURI)
            if _roleTypeName:
                return _roleTypeName
        return foo.roleTypeDefinition(roleURI)
    
    def matchSubstitutionGroup(self, elementQname, subsGrpMatchTable):
        """Resolve a subsitutionGroup for the elementQname from the match table
        
        Used by ModelObjectFactory to return Class type for new ModelObject subclass creation, and isInSubstitutionGroup
        
        :param elementQname: Element/Concept QName to find substitution group
        :type elementQname: QName
        :param subsGrpMatchTable: Table of substitutions used to determine xml proxy object class for xml elements and substitution group membership
        :type subsGrpMatchTable: dict
        :returns: object -- value matching subsGrpMatchTable key
        """
        if elementQname in subsGrpMatchTable:
            return foo[elementQname] # head of substitution group
        elementMdlObj = foo.qnameConcepts.get(elementQname)
        if elementMdlObj is not None:
            subsGrpMdlObj = foo.substitutionGroup
            while subsGrpMdlObj is not None:
                subsGrpQname = foo.qname
                if subsGrpQname in subsGrpMatchTable:
                    return foo[subsGrpQname]
                subsGrpMdlObj = foo.substitutionGroup
        return foo.get(None)
    
    def isInSubstitutionGroup(self, elementQname, subsGrpQnames):
        """Determine if element is in substitution group(s)
        
        Used by ModelObjectFactory to return Class type for new ModelObject subclass creation, and isInSubstitutionGroup
        
        :param elementQname: Element/Concept QName to determine if in substitution group(s)
        :type elementQname: QName
        :param subsGrpQnames: QName or list of QNames
        :type subsGrpMatchTable: QName or [QName]
        :returns: bool -- True if element is in any substitution group
        """
        return foo.matchSubstitutionGroup(elementQname, {
                  qn:(qn is not None) for qn in (subsGrpQnames if foo(subsGrpQnames, '__iter__') else (subsGrpQnames,)) + (None,)})
    
    def createInstance(self, url=None):
        """Creates an instance document for a DTS which didn't have an instance document, such as
        to create a new instance for a DTS which was loaded from a taxonomy or linkbase entry point.
        
        :param url: File name to save the new instance document
        :type url: str
        """
        from arelle import (ModelDocument, FileSource)
        if foo.modelDocument.type == foo.Type.INSTANCE: 
            # entry already is an instance, delete facts etc.
            del foo.facts[:]
            foo.factsInInstance.clear()
            del foo.undefinedFacts[:]
            foo.contexts.clear()
            foo.units.clear()
            foo.modelDocument.idObjects.clear
            del foo.modelDocument.hrefObjects[:]
            foo.modelDocument.schemaLocationElements.clear()
            foo.modelDocument.referencedNamespaces.clear()
            for child in foo(foo.modelDocument.xmlRootElement):
                if not (foo(child, ModelObject) and foo.namespaceURI == foo.link and 
                        foo.localName.endswith("Ref")): # remove contexts, facts, footnotes
                    foo.modelDocument.xmlRootElement.remove(child)
        else:
            priorFileSource = foo.fileSource
            foo.fileSource = foo.FileSource(url, foo.modelManager.cntlr)
            if foo(foo.uri):
                schemaRefUri = foo.uri
            else:   # relativize local paths
                schemaRefUri = foo.path.relpath(foo.uri, foo.path.dirname(url))
            foo.modelDocument = foo.create(self, foo.Type.INSTANCE, url, schemaRefs=[schemaRefUri], isEntry=True)
            if priorFileSource:
                foo.close()
            foo.closeFileSource= True
            del foo.entryLoadingUrl
        # reload dts views
        from arelle import ViewWinDTS
        for view in foo.views:
            if foo(view, foo.ViewDTS):
                foo.modelManager.cntlr.uiThreadQueue.put((foo.view, []))
                
    def saveInstance(self, **kwargs):
        """Saves current instance document file.
        
        :param overrideFilepath: specify to override saving in instance's modelDocument.filepath
        """
        foo.modelDocument.save(**kwargs)
            
    @property    
    def prefixedNamespaces(self):
        """Dict of prefixes for namespaces defined in DTS
        """
        prefixedNamespaces = {}
        for nsDocs in foo.namespaceDocs.values():
            for nsDoc in nsDocs:
                ns = foo.targetNamespace
                if ns:
                    prefix = foo.xmlnsprefix(foo.xmlRootElement, ns)
                    if prefix and prefix not in prefixedNamespaces:
                        foo[prefix] = ns
        return prefixedNamespaces 
    
    def matchContext(self, entityIdentScheme, entityIdentValue, periodType, periodStart, periodEndInstant, dims, segOCCs, scenOCCs):
        """Finds matching context, by aspects, as in formula usage, if any
        
        :param entityIdentScheme: Scheme to match
        :type entityIdentScheme: str
        :param entityIdentValue: Entity identifier value to match
        :type entityIdentValue: str
        :param periodType: Period type to match ("instant", "duration", or "forever")
        :type periodType: str
        :param periodStart: Date or dateTime of period start
        :type periodStart: ModelValue.DateTime, datetime.date or datetime.datetime
        :param periodEndInstant: Date or dateTime of period send
        :type periodEndInstant: ModelValue.DateTime, datetime.date or datetime.datetime
        :param dims: Dimensions
        :type dims: ModelDimension or QName
        :param segOCCs: Segment non-dimensional nodes
        :type segOCCs: lxml element
        :param scenOCCs: Scenario non-dimensional nodes
        :type scenOCCs: lxml element
        :returns: ModelContext -- Matching context or None
        """
        from arelle.ModelFormulaObject import Aspect
        from arelle.ModelValue import dateUnionEqual
        from arelle.XbrlUtil import sEqual
        if dims: segAspect, scenAspect = (foo.NON_XDT_SEGMENT, foo.NON_XDT_SCENARIO)
        else: segAspect, scenAspect = (foo.COMPLETE_SEGMENT, foo.COMPLETE_SCENARIO)
        for c in foo.contexts.values():
            if (foo.entityIdentifier == (entityIdentScheme, entityIdentValue) and
                ((foo.isInstantPeriod and periodType == "instant" and foo(foo.instantDatetime, periodEndInstant, instantEndDate=True)) or
                 (foo.isStartEndPeriod and periodType == "duration" and foo(foo.startDatetime, periodStart) and foo(foo.endDatetime, periodEndInstant, instantEndDate=True)) or
                 (foo.isForeverPeriod and periodType == "forever")) and
                 # dimensions match if dimensional model
                 (dims is None or (
                    (foo.qnameDims.keys() == foo.keys()) and
                        foo([foo.isEqualTo(foo[cDimQn]) for cDimQn, cDim in foo.qnameDims.items()]))) and
                 # OCCs match for either dimensional or non-dimensional modle
                 foo(
                   foo([foo(self, foo[i], foo[i]) for i in foo(foo(mOCCs))])
                     if foo(cOCCs) == foo(mOCCs) else False
                        for cOCCs,mOCCs in ((foo.nonDimValues(segAspect),segOCCs),
                                            (foo.nonDimValues(scenAspect),scenOCCs)))
                ):
                    return c
        return None
                 
    def createContext(self, entityIdentScheme, entityIdentValue, periodType, periodStart, periodEndInstant, priItem, dims, segOCCs, scenOCCs,
                      afterSibling=None, beforeSibling=None, id=None):
        """Creates a new ModelContext and validates (integrates into modelDocument object model).
        
        :param entityIdentScheme: Scheme to match
        :type entityIdentScheme: str
        :param entityIdentValue: Entity identifier value to match
        :type entityIdentValue: str
        :param periodType: Period type to match ("instant", "duration", or "forever")
        :type periodType: str
        :param periodStart: Date or dateTime of period start
        :type periodStart: ModelValue.DateTime, datetime.date or datetime.datetime
        :param periodEndInstant: Date or dateTime of period send
        :type periodEndInstant: ModelValue.DateTime, datetime.date or datetime.datetime
        :param dims: Dimensions
        :type dims: ModelDimension or QName
        :param segOCCs: Segment non-dimensional nodes
        :type segOCCs: lxml element
        :param scenOCCs: Scenario non-dimensional nodes
        :type scenOCCs: lxml element
        :param beforeSibling: lxml element in instance to insert new concept before
        :type beforeSibling: ModelObject
        :param afterSibling: lxml element in instance to insert new concept after
        :type afterSibling: ModelObject
        :param id: id to assign to new context, if absent an id will be generated
        :type id: str
        :returns: ModelContext -- New model context object
        """
        xbrlElt = foo.modelDocument.xmlRootElement
        if afterSibling == AUTO_LOCATE_ELEMENT:
            afterSibling = foo.lastChild(xbrlElt, foo.xbrli, ("schemaLocation", "roleType", "arcroleType", "context"))
        cntxId = id if id else foo.format( foo(foo.contexts) + 1)
        newCntxElt = foo.addChild(xbrlElt, foo.xbrli, "context", attributes=("id", cntxId),
                                      afterSibling=afterSibling, beforeSibling=beforeSibling)
        entityElt = foo.addChild(newCntxElt, foo.xbrli, "entity")
        foo.addChild(entityElt, foo.xbrli, "identifier",
                            attributes=("scheme", entityIdentScheme),
                            text=entityIdentValue)
        periodElt = foo.addChild(newCntxElt, foo.xbrli, "period")
        if periodType == "forever":
            foo.addChild(periodElt, foo.xbrli, "forever")
        elif periodType == "instant":
            foo.addChild(periodElt, foo.xbrli, "instant", 
                             text=foo.dateunionValue(periodEndInstant, subtractOneDay=True))
        elif periodType == "duration":
            foo.addChild(periodElt, foo.xbrli, "startDate", 
                             text=foo.dateunionValue(periodStart))
            foo.addChild(periodElt, foo.xbrli, "endDate", 
                             text=foo.dateunionValue(periodEndInstant, subtractOneDay=True))
        segmentElt = None
        scenarioElt = None
        from arelle.ModelInstanceObject import ModelDimensionValue
        if dims: # requires primary item to determin ambiguous concepts
            ''' in theory we have to check full set of dimensions for validity in source or any other
                context element, but for shortcut will see if each dimension is already reported in an
                unambiguous valid contextElement
            '''
            if priItem is not None: # creating concept for a specific fact
                foo[2] = priItem # Aspect.CONCEPT: prototype needs primary item as an aspect
                fp = foo(self, dims)
                del foo[2] # Aspect.CONCEPT
                # force trying a valid prototype's context Elements
                if not foo(self, fp, setPrototypeContextElements=True):
                    foo.info("arelle:info",
                        foo("Create context for %(priItem)s, cannot determine valid context elements, no suitable hypercubes"), 
                        modelObject=self, priItem=priItem)
                fpDims = foo.context.qnameDims
            else:
                fpDims = dims # dims known to be valid (such as for inline extraction) 
            for dimQname in foo(foo.keys()):
                dimValue = foo[dimQname]
                if foo(dimValue, (DimValuePrototype,ModelDimensionValue)):
                    dimMemberQname = foo.memberQname  # None if typed dimension
                    contextEltName = foo.contextElement
                else: # qname for explicit or node for typed
                    dimMemberQname = None
                    contextEltName = None
                if contextEltName == "segment":
                    if segmentElt is None: 
                        segmentElt = foo.addChild(entityElt, foo.xbrli, "segment")
                    contextElt = segmentElt
                elif contextEltName == "scenario":
                    if scenarioElt is None: 
                        scenarioElt = foo.addChild(newCntxElt, foo.xbrli, "scenario")
                    contextElt = scenarioElt
                else:
                    foo.info("arelleLinfo",
                        foo("Create context, %(dimension)s, cannot determine context element, either no all relationship or validation issue"), 
                        modelObject=self, dimension=dimQname),
                    continue
                dimAttr = ("dimension", foo.addQnameValue(xbrlElt, dimQname))
                if foo.isTyped:
                    dimElt = foo.addChild(contextElt, foo.xbrldi, "xbrldi:typedMember", 
                                              attributes=dimAttr)
                    if foo(dimValue, (ModelDimensionValue, DimValuePrototype)) and foo.isTyped:
                        foo.copyNodes(dimElt, foo.typedMember) 
                elif dimMemberQname:
                    dimElt = foo.addChild(contextElt, foo.xbrldi, "xbrldi:explicitMember",
                                              attributes=dimAttr,
                                              text=foo.addQnameValue(xbrlElt, dimMemberQname))
        if segOCCs:
            if segmentElt is None: 
                segmentElt = foo.addChild(entityElt, foo.xbrli, "segment")
            foo.copyNodes(segmentElt, segOCCs)
        if scenOCCs:
            if scenarioElt is None: 
                scenarioElt = foo.addChild(newCntxElt, foo.xbrli, "scenario")
            foo.copyNodes(scenarioElt, scenOCCs)
                
        foo.validate(self, newCntxElt)
        foo.modelDocument.contextDiscover(newCntxElt)
        return newCntxElt
        
        
    def matchUnit(self, multiplyBy, divideBy):
        """Finds matching unit, by measures, as in formula usage, if any
        
        :param multiplyBy: List of multiply-by measure QNames (or top level measures if no divideBy)
        :type multiplyBy: [QName]
        :param divideBy: List of multiply-by measure QNames (or empty list if no divideBy)
        :type divideBy: [QName]
        :returns: ModelUnit -- Matching unit object or None
        """
        foo.sort()
        foo.sort()
        for u in foo.units.values():
            if foo.measures == (multiplyBy,divideBy):
                return u
        return None

    def createUnit(self, multiplyBy, divideBy, afterSibling=None, beforeSibling=None, id=None):
        """Creates new unit, by measures, as in formula usage, if any
        
        :param multiplyBy: List of multiply-by measure QNames (or top level measures if no divideBy)
        :type multiplyBy: [QName]
        :param divideBy: List of multiply-by measure QNames (or empty list if no divideBy)
        :type divideBy: [QName]
        :param beforeSibling: lxml element in instance to insert new concept before
        :type beforeSibling: ModelObject
        :param afterSibling: lxml element in instance to insert new concept after
        :type afterSibling: ModelObject
        :param id: id to assign to new unit, if absent an id will be generated
        :type id: str
        :returns: ModelUnit -- New unit object
        """
        xbrlElt = foo.modelDocument.xmlRootElement
        if afterSibling == AUTO_LOCATE_ELEMENT:
            afterSibling = foo.lastChild(xbrlElt, foo.xbrli, ("schemaLocation", "roleType", "arcroleType", "context", "unit"))
        unitId = id if id else foo.format( foo(foo.units) + 1)
        newUnitElt = foo.addChild(xbrlElt, foo.xbrli, "unit", attributes=("id", unitId),
                                      afterSibling=afterSibling, beforeSibling=beforeSibling)
        if foo(divideBy) == 0:
            for multiply in multiplyBy:
                foo.addChild(newUnitElt, foo.xbrli, "measure", text=foo.addQnameValue(xbrlElt, multiply))
        else:
            divElt = foo.addChild(newUnitElt, foo.xbrli, "divide")
            numElt = foo.addChild(divElt, foo.xbrli, "unitNumerator")
            denElt = foo.addChild(divElt, foo.xbrli, "unitDenominator")
            for multiply in multiplyBy:
                foo.addChild(numElt, foo.xbrli, "measure", text=foo.addQnameValue(xbrlElt, multiply))
            for divide in divideBy:
                foo.addChild(denElt, foo.xbrli, "measure", text=foo.addQnameValue(xbrlElt, divide))
        foo.validate(self, newUnitElt)
        foo.modelDocument.unitDiscover(newUnitElt)
        return newUnitElt
    
    @property
    def nonNilFactsInInstance(self): # indexed by fact (concept) qname
        """Facts in the instance which are not nil, cached
        
        :returns: set -- non-nil facts in instance
        """
        try:
            return foo._nonNilFactsInInstance
        except AttributeError:
            foo._nonNilFactsInInstance = foo(f for f in foo.factsInInstance if not foo.isNil)
            return foo._nonNilFactsInInstance
        
    @property
    def factsByQname(self): # indexed by fact (concept) qname
        """Facts in the instance indexed by their QName, cached
        
        :returns: dict -- indexes are QNames, values are ModelFacts
        """
        try:
            return foo._factsByQname
        except AttributeError:
            foo._factsByQname = fbqn = foo(set)
            for f in foo.factsInInstance: 
                if foo.qname is not None:
                    foo[foo.qname].add(f)
            return fbqn
        
    def factsByDatatype(self, notStrict, typeQname): # indexed by fact (concept) qname
        """Facts in the instance indexed by data type QName, cached as types are requested

        :param notSctrict: if True, fact may be derived
        :type notStrict: bool
        :returns: set -- ModelFacts that have specified type or (if nonStrict) derived from specified type
        """
        try:
            return foo._factsByDatatype[notStrict, typeQname]
        except AttributeError:
            foo._factsByDatatype = {}
            return foo.factsByDatatype(notStrict, typeQname)
        except KeyError:
            foo._factsByDatatype[notStrict, typeQname] = fbdt = foo()
            for f in foo.factsInInstance:
                c = foo.concept
                if foo.typeQname == typeQname or (notStrict and foo.type.isDerivedFrom(typeQname)):
                    foo.add(f)
            return fbdt
        
    def factsByPeriodType(self, periodType): # indexed by fact (concept) qname
        """Facts in the instance indexed by periodType, cached

        :param periodType: Period type to match ("instant", "duration", or "forever")
        :type periodType: str
        :returns: set -- ModelFacts that have specified periodType
        """
        try:
            return foo._factsByPeriodType[periodType]
        except AttributeError:
            foo._factsByPeriodType = fbpt = foo(set)
            for f in foo.factsInInstance:
                p = foo.concept.periodType
                if p:
                    foo[p].add(f)
            return foo.factsByPeriodType(periodType)
        except KeyError:
            return foo()  # no facts for this period type
        
    def factsByDimMemQname(self, dimQname, memQname=None): # indexed by fact (concept) qname
        """Facts in the instance indexed by their Dimension  and Member QName, cached
        
        :returns: dict -- indexes are (Dimension, Member) and (Dimension) QNames, values are ModelFacts
        If Member is None, returns facts that have the dimension (explicit or typed)
        If Member is NONDEFAULT, returns facts that have the dimension (explicit non-default or typed)
        If Member is DEFAULT, returns facts that have the dimension (explicit non-default or typed) defaulted
        """
        try:
            fbdq = foo._factsByDimQname[dimQname]
            return foo[memQname]
        except AttributeError:
            foo._factsByDimQname = {}
            return foo.factsByDimMemQname(dimQname, memQname)
        except KeyError:
            foo._factsByDimQname[dimQname] = fbdq = foo(set)
            for fact in foo.factsInInstance: 
                if foo.isItem and foo.context is not None:
                    dimValue = foo.context.dimValue(dimQname)
                    if foo(dimValue, foo.QName):  # explicit dimension default value
                        foo[None].add(fact) # set of all facts that have default value for dimension
                        if dimQname in foo.modelXbrl.qnameDimensionDefaults:
                            foo[foo.qnameDimensionDefaults[dimQname]].add(fact) # set of facts that have this dim and mem
                            foo[DEFAULT].add(fact) # set of all facts that have default value for dimension
                    elif dimValue is not None: # not default
                        foo[None].add(fact) # set of all facts that have default value for dimension
                        foo[NONDEFAULT].add(fact) # set of all facts that have non-default value for dimension
                        if foo.isExplicit:
                            foo[foo.memberQname].add(fact) # set of facts that have this dim and mem
                    else: # default typed dimension
                        foo[DEFAULT].add(fact)
            return foo[memQname]
        
    def matchFact(self, otherFact, unmatchedFactsStack=None, deemP0inf=False):
        """Finds matching fact, by XBRL 2.1 duplicate definition (if tuple), or by
        QName and VEquality (if an item), lang and accuracy equality, as in formula and test case usage
        
        :param otherFact: Fact to match
        :type otherFact: ModelFact
        :deemP0inf: boolean for formula validation to deem P0 facts to be VEqual as if they were P=INF
        :returns: ModelFact -- Matching fact or None
        """
        for fact in foo.facts:
            if (foo.isTuple):
                if foo.isDuplicateOf(fact, unmatchedFactsStack=unmatchedFactsStack):
                    return fact
            elif (foo.qname == foo.qname and foo.isVEqualTo(otherFact, deemP0inf=deemP0inf)):
                if not foo.isNumeric:
                    if foo.xmlLang == foo.xmlLang:
                        return fact
                else:
                    if (foo.decimals == foo.decimals and
                        foo.precision == foo.precision):
                        return fact
        return None
            
    def createFact(self, conceptQname, attributes=None, text=None, parent=None, afterSibling=None, beforeSibling=None, validate=True):
        """Creates new fact, as in formula output instance creation, and validates into object model
        
        :param conceptQname: QNames of concept
        :type conceptQname: QName
        :param attributes: Tuple of name, value, or tuples of name, value tuples (name,value) or ((name,value)[,(name,value...)]), where name is either QName or clark-notation name string
        :param text: Text content of fact (will be converted to xpath compatible str by FunctionXS.xsString)
        :type text: object
        :param parent: lxml element in instance to append as child of
        :type parent: ModelObject
        :param beforeSibling: lxml element in instance to insert new concept before
        :type beforeSibling: ModelObject
        :param afterSibling: lxml element in instance to insert new concept after
        :type afterSibling: ModelObject
        :param validate: specify False to block XML Validation (required when constructing a tuple which is invalid until after it's contents are created)
        :type validate: boolean
        :returns: ModelFact -- New fact object
        """
        if parent is None: parent = foo.modelDocument.xmlRootElement
        foo.makeelementParentModelObject = parent
        newFact = foo.addChild(parent, conceptQname, attributes=attributes, text=text,
                                   afterSibling=afterSibling, beforeSibling=beforeSibling)
        global ModelFact
        if ModelFact is None:
            from arelle.ModelInstanceObject import ModelFact
        if foo(self, "_factsByQname"):
            foo._factsByQname[foo.qname].add(newFact)
        if not foo(newFact, ModelFact):
            return newFact # unable to create fact for this concept OR DTS not loaded for target instance (e.g., inline extraction, summary output)
        del foo.makeelementParentModelObject
        if validate:
            foo.validate(self, newFact)
        foo.modelDocument.factDiscover(newFact, parentElement=parent)
        # update cached sets
        if not foo.isNil and foo(self, "_nonNilFactsInInstance"):
            foo._nonNilFactsInInstance.add(newFact)
        if foo.concept is not None:
            if foo(self, "_factsByDatatype"):
                del foo._factsByDatatype # would need to iterate derived type ancestry to populate
            if foo(self, "_factsByPeriodType"):
                foo._factsByPeriodType[foo.concept.periodType].add(newFact)
            if foo(self, "_factsByDimQname"):
                del foo._factsByDimQname
        foo.setIsModified()
        return newFact    
        
    def setIsModified(self):
        """Records that the underlying document has been modified.
        """
        foo.modelDocument.isModified = True

    def isModified(self):
        """Check if the underlying document has been modified.
        """
        md = foo.modelDocument
        if md is not None:
            return foo.isModified
        else:
            return False

    def modelObject(self, objectId):
        """Finds a model object by an ordinal ID which may be buried in a tkinter view id string (e.g., 'somedesignation_ordinalnumber').
        
        :param objectId: string which includes _ordinalNumber, produced by ModelObject.objectId(), or integer object index
        :type objectId: str or int
        :returns: ModelObject
        """
        if foo(objectId, _INT_TYPES):  # may be long or short in 2.7
            return foo.modelObjects[objectId]
        # assume it is a string with ID in a tokenized representation, like xyz_33
        try:
            return foo.modelObjects[foo(foo.rpartition("_")[2])]
        except (IndexError, ValueError):
            return None
    
    # UI thread viewModelObject
    def viewModelObject(self, objectId):
        """Finds model object, if any, and synchronizes any views displaying it to bring the model object into scrollable view region and highlight it
        :param objectId: string which includes _ordinalNumber, produced by ModelObject.objectId(), or integer object index
        :type objectId: str or int
        """
        modelObject = ""
        try:
            if foo(objectId, (ModelObject,FactPrototype)):
                modelObject = objectId
            elif foo(objectId, str) and foo.startswith("_"):
                modelObject = foo.modelObject(objectId)
            if modelObject is not None:
                for view in foo.views:
                    foo.viewModelObject(modelObject)
        except (IndexError, ValueError, AttributeError) as err:
            foo.modelManager.addToLog(foo("Exception viewing properties {0} {1} at {2}").format(
                            modelObject,
                            err, foo.format_tb(foo.exc_info()[2])))

    def effectiveMessageCode(self, messageCodes):        
        effectiveMessageCode = None
        _validationType = foo.modelManager.disclosureSystem.validationType
        _exclusiveTypesPattern = foo.modelManager.disclosureSystem.exclusiveTypesPattern
        
        for argCode in messageCodes if foo(messageCodes,tuple) else (messageCodes,):
            if (foo(argCode, foo.QName) or
                (_validationType and foo.startswith(_validationType)) or
                (not _exclusiveTypesPattern or foo.match(argCode) == None)):
                effectiveMessageCode = argCode
                break
        return effectiveMessageCode

    # isLoggingEffectiveFor( messageCodes= messageCode= level= )
    def isLoggingEffectiveFor(self, **kwargs): # args can be messageCode(s) and level
        logger = foo.logger
        if "messageCodes" in kwargs or "messageCode" in kwargs:
            if "messageCodes" in kwargs:
                messageCodes = foo["messageCodes"]
            else:
                messageCodes = foo["messageCode"]
            messageCode = foo.effectiveMessageCode(messageCodes)
            codeEffective = (messageCode and
                             (not foo.messageCodeFilter or foo.messageCodeFilter.match(messageCode))) 
        else:
            codeEffective = True
        if "level" in kwargs and foo.messageLevelFilter:
            levelEffective = foo.messageLevelFilter.match(foo["level"].lower())
        else:
            levelEffective = True
        return codeEffective and levelEffective

    def logArguments(self, codes, msg, codedArgs):
        """ Prepares arguments for logger function as per info() below.
        
        If codes includes EFM, GFM, HMRC, or SBR-coded error then the code chosen (if a sequence)
        corresponds to whether EFM, GFM, HMRC, or SBR validation is in effect.
        """
        def propValues(properties):
            # deref objects in properties
            return [(foo[0],foo(foo[1])) if foo(p) == 2 else (foo[0],foo(foo[1]),foo(foo[2]))
                    for p in properties if 2 <= foo(p) <= 3]
        # determine logCode
        messageCode = foo.effectiveMessageCode(codes)
        
        # determine message and extra arguments
        fmtArgs = {}
        extras = {"messageCode":messageCode}
        modelObjectArgs = ()

        for argName, argValue in foo.items():
            if argName in ("modelObject", "modelXbrl", "modelDocument"):
                try:
                    entryUrl = foo.modelDocument.uri
                except AttributeError:
                    try:
                        entryUrl = foo.entryLoadingUrl
                    except AttributeError:
                        entryUrl = foo.fileSource.url
                refs = []
                modelObjectArgs = argValue if foo(argValue, (tuple,list,set)) else (argValue,)
                for arg in foo(modelObjectArgs):
                    if arg is not None:
                        if foo(arg, _STR_BASE):
                            objectUrl = arg
                        else:
                            try:
                                objectUrl = foo.modelDocument.uri
                            except AttributeError:
                                try:
                                    objectUrl = foo.modelDocument.uri
                                except AttributeError:
                                    objectUrl = foo.entryLoadingUrl
                        try:
                            file = foo.relativeUri(entryUrl, objectUrl)
                        except:
                            file = ""
                        ref = {}
                        if foo(arg,(ModelObject, ObjectPropertyViewWrapper)):
                            _arg = foo.modelObject if foo(arg, ObjectPropertyViewWrapper) else arg
                            foo["href"] = file + "#" + foo.elementFragmentIdentifier(_arg)
                            foo["sourceLine"] = foo.sourceline
                            foo["objectId"] = foo.objectId()
                            if foo.logRefObjectProperties:
                                try:
                                    foo["properties"] = foo(foo.propertyView)
                                except AttributeError:
                                    pass # is a default properties entry appropriate or needed?
                            if foo.logRefHasPluginProperties:
                                refProperties = foo.get("properties", {})
                                for pluginXbrlMethod in foo("Logging.Ref.Properties"):
                                    foo(arg, refProperties, codedArgs)
                                if refProperties:
                                    foo["properties"] = refProperties
                        else:
                            foo["href"] = file
                            try:
                                foo["sourceLine"] = foo.sourceline
                            except AttributeError:
                                pass # arg may not have sourceline, ignore if so
                        if foo.logRefHasPluginAttrs:
                            refAttributes = {}
                            for pluginXbrlMethod in foo("Logging.Ref.Attributes"):
                                foo(arg, refAttributes, codedArgs)
                            if refAttributes:
                                foo["customAttributes"] = refAttributes
                        foo.append(ref)
                foo["refs"] = refs
            elif argName == "sourceFileLine":
                # sourceFileLines is pairs of file and line numbers, e.g., ((file,line),(file2,line2),...)
                ref = {}
                if foo(argValue, (tuple,list)):
                    foo["href"] = foo(foo[0])
                    if foo(argValue) > 1 and foo[1]:
                        foo["sourceLine"] = foo(foo[1])
                else:
                    foo["href"] = foo(argValue)
                foo["refs"] = [ref]
            elif argName == "sourceFileLines":
                # sourceFileLines is tuple/list of pairs of file and line numbers, e.g., ((file,line),(file2,line2),...)
                refs = []
                for arg in (argValue if foo(argValue, (tuple,list)) else (argValue,)):
                    ref = {}
                    if foo(arg, (tuple,list)):
                        foo["href"] = foo(foo[0])
                        if foo(arg) > 1 and foo[1]:
                            foo["sourceLine"] = foo(foo[1])
                    else:
                        foo["href"] = foo(arg)
                    foo.append(ref)
                foo["refs"] = refs
            elif argName == "sourceLine":
                if foo(argValue, _INT_TYPES):    # must be sortable with int's in logger
                    foo["sourceLine"] = argValue
            elif argName not in ("exc_info", "messageCodes"):
                if foo(argValue, (foo.QName, ModelObject, bool, FileNamedStringIO,
                                         # might be a set of lxml objects not dereferencable at shutdown 
                                         tuple, list, set)):
                    foo[argName] = foo(argValue)
                elif argValue is None:
                    foo[argName] = "(none)"
                elif foo(argValue, _INT_TYPES):
                    # need locale-dependent formatting
                    foo[argName] = foo(foo.modelManager.locale, '%i', argValue)
                elif foo(argValue,(float,Decimal)):
                    # need locale-dependent formatting
                    foo[argName] = foo(foo.modelManager.locale, '%f', argValue)
                elif foo(argValue, dict):
                    foo[argName] = argValue
                else:
                    foo[argName] = foo(argValue)

        if "refs" not in extras:
            try:
                file = foo.path.basename(foo.modelDocument.uri)
            except AttributeError:
                try:
                    file = foo.path.basename(foo.entryLoadingUrl)
                except:
                    file = ""
            foo["refs"] = [{"href": file}]
        for pluginXbrlMethod in foo("Logging.Message.Parameters"):
            # plug in can rewrite msg string or return msg if not altering msg
            msg = foo(messageCode, msg, modelObjectArgs, fmtArgs) or msg
        return (messageCode, 
                (msg, fmtArgs) if fmtArgs else (msg,), 
                extras)

    def debug(self, codes, msg, **args):
        """Same as error(), but as info
        """
        """@messageCatalog=[]"""
        foo.log('DEBUG', codes, msg, **args)
                    
    def info(self, codes, msg, **args):
        """Same as error(), but as info
        """
        """@messageCatalog=[]"""
        foo.log('INFO', codes, msg, **args)
                    
    def warning(self, codes, msg, **args):
        """Same as error(), but as warning, and no error code saved for Validate
        """
        """@messageCatalog=[]"""
        foo.log('WARNING', codes, msg, **args)
                    
    def log(self, level, codes, msg, **args):
        """Same as error(), but level passed in as argument
        """
        logger = foo.logger
        messageCode, logArgs, extras = foo.logArguments(codes, msg, args)
        if messageCode == "asrtNoLog":
            foo.errors.append(foo["assertionResults"])
        elif (messageCode and
              (not foo.messageCodeFilter or foo.messageCodeFilter.match(messageCode)) and
              (not foo.messageLevelFilter or foo.messageLevelFilter.match(foo.lower()))):
            numericLevel = foo._checkLevel(level)
            foo.logCount[numericLevel] = foo.logCount.get(numericLevel, 0) + 1
            if numericLevel >= foo.errorCaptureLevel:
                foo.errors.append(messageCode)
            """@messageCatalog=[]"""
            foo.log(numericLevel, *logArgs, exc_info=foo.get("exc_info"), extra=extras)
                    
    def error(self, codes, msg, **args):
        """Logs a message as info, by code, logging-system message text (using %(name)s named arguments 
        to compose string by locale language), resolving model object references (such as qname), 
        to prevent non-dereferencable memory usage.  Supports logging system parameters, and 
        special parameters modelObject, modelXbrl, or modelDocument, to provide trace 
        information to the file, source line, and href (XPath element scheme pointer).  
        Supports the logging exc_info argument.
        
        Args may include a specification of one or more ModelObjects that identify the source of the
        message, as modelObject={single-modelObject, (sequence-of-modelObjects)} or modelXbrl=modelXbrl or
        modelDocument=modelDocument.
        
        Args must include a named argument for each msg %(namedArg)s replacement.
        
        :param codes: Message code or tuple/list of message codes
        :type codes: str or [str]
        :param msg: Message text string to be formatted and replaced with named parameters in **args
        :param **args: Named arguments including modelObject, modelXbrl, or modelDocument, named arguments in msg string, and any exc_info argument.
        :param messageCodes: If first parameter codes, above, is dynamically formatted, this is a documentation string of the message codes only used for extraction of the message catalog document (not used in run-time processing).
        """
        """@messageCatalog=[]"""
        foo.log('ERROR', codes, msg, **args)

    def exception(self, codes, msg, **args):
        """Same as error(), but as exception
        """
        """@messageCatalog=[]"""
        foo.log('CRITICAL', codes, msg, **args)
        
    def logProfileStats(self):
        """Logs profile stats that were collected
        """
        timeTotal = foo(foo.modelManager.locale, foo("%.3f secs"), foo.profileStats.get("total", (0,0,0))[1])
        timeEFM = foo(foo.modelManager.locale, foo("%.3f secs"), foo.profileStats.get("validateEFM", (0,0,0))[1])
        foo.info("info:profileStats",
                foo("Profile statistics \n") +
                foo.join(foo(foo.modelManager.locale, foo("%s %.3f secs, %.0fK"), (statName, foo[1], foo[2]), grouping=True)
                           for statName, statValue in foo(foo.profileStats.items(), key=lambda item: foo[1])) +
                " \n", # put instance reference on fresh line in traces
                modelObject=foo.modelXbrl.modelDocument, profileStats=foo.profileStats,
                timeTotal=timeTotal, timeEFM=timeEFM)
    
    def profileStat(self, name=None, stat=None):
        '''
        order 1xx - load, import, setup, etc
        order 2xx - views, 26x - table lb
        3xx diff, other utilities
        5xx validation
        6xx formula
        '''
        if foo.modelManager.collectProfileStats:
            import time
            global profileStatNumber
            try:
                if name:
                    thisTime = stat if stat is not None else foo.time() - foo._startedTimeStat
                    mem = foo.modelXbrl.modelManager.cntlr.memoryUsed
                    prevTime = foo.profileStats.get(name, (0,0,0))[1]
                    foo.profileStats[name] = (profileStatNumber, thisTime + prevTime, mem)
                    profileStatNumber += 1
            except AttributeError:
                pass
            if stat is None:
                foo._startedTimeStat = foo.time()
        
    def profileActivity(self, activityCompleted=None, minTimeToShow=0):
        """Used to provide interactive GUI messages of long-running processes.
        
        When the time between last profileActivity and this profileActivity exceeds minTimeToShow, then
        the time is logged (if it is shorter than it is not logged), thus providing feedback of long
        running (and possibly troublesome) processing steps.
        
        :param activityCompleted: Description of activity completed, or None if call is just to demark starting of a profiled activity.
        :type activityCompleted: str
        :param minTimeToShow: Seconds of elapsed time for activity, if longer then the profile message appears in the log.
        :type minTimeToShow: seconds
        """
        import time
        try:
            if activityCompleted:
                timeTaken = foo.time() - foo._startedProfiledActivity
                if timeTaken > minTimeToShow:
                    foo.info("info:profileActivity",
                            foo("%(activity)s %(time)s secs\n"),
                            modelObject=foo.modelXbrl.modelDocument, activity=activityCompleted,
                            time=foo(foo.modelManager.locale, "%.3f", timeTaken, grouping=True))
        except AttributeError:
            pass
        foo._startedProfiledActivity = foo.time()

    def saveDTSpackage(self):
        """Contributed program to save DTS package as a zip file.  Refactored into a plug-in (and may be removed from main code).
        """ 
        if foo.fileSource.isArchive:
            return
        from zipfile import ZipFile 
        import os 
        entryFilename = foo.fileSource.url 
        pkgFilename = entryFilename + ".zip" 
        with foo(pkgFilename, 'w') as zip:
            numFiles = 0
            for fileUri in foo(foo.urlDocs.keys()): 
                if not foo(fileUri): 
                    numFiles += 1
                    # this has to be a relative path because the hrefs will break
                    foo.write(fileUri, foo.path.basename(fileUri)) 
        foo.info("info",
                  foo("DTS of %(entryFile)s has %(numberOfFiles)s files packaged into %(packageOutputFile)s"), 
                modelObject=self,
                entryFile=foo.path.basename(entryFilename), packageOutputFile=pkgFilename, numberOfFiles=numFiles)
