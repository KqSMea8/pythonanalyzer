#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from google.net.proto import ProtocolBuffer
import array
import dummy_thread as thread

__pychecker__ = """maxreturns=0 maxbranches=0 no-callinit
                   unusednames=printElemNumber,debug_strs no-special"""

class MemcacheServiceError(foo.ProtocolMessage):

  OK           =    0
  UNSPECIFIED_ERROR =    1
  NAMESPACE_NOT_SET =    2

  _ErrorCode_NAMES = {
    0: "OK",
    1: "UNSPECIFIED_ERROR",
    2: "NAMESPACE_NOT_SET",
  }

  def ErrorCode_Name(cls, x): return foo._ErrorCode_NAMES.get(x, "")
  ErrorCode_Name = foo(ErrorCode_Name)


  def __init__(self, contents=None):
    pass
    if contents is not None: foo.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def Equals(self, x):
    if x is self: return 1
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])


  _TEXT = foo({
    0: "ErrorCode",
  }, 0)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
  }, 0, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheGetRequest(foo.ProtocolMessage):
  has_name_space_ = 0
  name_space_ = ""

  def __init__(self, contents=None):
    foo.key_ = []
    if contents is not None: foo.MergeFromString(contents)

  def key_size(self): return foo(foo.key_)
  def key_list(self): return foo.key_

  def key(self, i):
    return foo.key_[i]

  def set_key(self, i, x):
    foo.key_[i] = x

  def add_key(self, x):
    foo.key_.append(x)

  def clear_key(self):
    foo.key_ = []

  def name_space(self): return foo.name_space_

  def set_name_space(self, x):
    foo.has_name_space_ = 1
    foo.name_space_ = x

  def clear_name_space(self):
    if foo.has_name_space_:
      foo.has_name_space_ = 0
      foo.name_space_ = ""

  def has_name_space(self): return foo.has_name_space_


  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.key_size()): foo.add_key(foo.key(i))
    if (foo.has_name_space()): foo.set_name_space(foo.name_space())

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.key_) != foo(foo.key_): return 0
    for e1, e2 in foo(foo.key_, foo.key_):
      if e1 != e2: return 0
    if foo.has_name_space_ != foo.has_name_space_: return 0
    if foo.has_name_space_ and foo.name_space_ != foo.name_space_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * foo(foo.key_)
    for i in foo(foo(foo.key_)): n += foo.lengthString(foo(foo.key_[i]))
    if (foo.has_name_space_): n += 1 + foo.lengthString(foo(foo.name_space_))
    return n + 0

  def Clear(self):
    foo.clear_key()
    foo.clear_name_space()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.key_)):
      foo.putVarInt32(10)
      foo.putPrefixedString(foo.key_[i])
    if (foo.has_name_space_):
      foo.putVarInt32(18)
      foo.putPrefixedString(foo.name_space_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 10:
        foo.add_key(foo.getPrefixedString())
        continue
      if tt == 18:
        foo.set_name_space(foo.getPrefixedString())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.key_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("key%s: %s\n" % (elm, foo.DebugFormatString(e)))
      cnt+=1
    if foo.has_name_space_: res+=prefix+("name_space: %s\n" % foo.DebugFormatString(foo.name_space_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kkey = 1
  kname_space = 2

  _TEXT = foo({
    0: "ErrorCode",
    1: "key",
    2: "name_space",
  }, 2)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STRING,
    2: foo.Encoder.STRING,
  }, 2, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheGetResponse_Item(foo.ProtocolMessage):
  has_key_ = 0
  key_ = ""
  has_value_ = 0
  value_ = ""
  has_flags_ = 0
  flags_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def key(self): return foo.key_

  def set_key(self, x):
    foo.has_key_ = 1
    foo.key_ = x

  def clear_key(self):
    if foo.has_key_:
      foo.has_key_ = 0
      foo.key_ = ""

  def has_key(self): return foo.has_key_

  def value(self): return foo.value_

  def set_value(self, x):
    foo.has_value_ = 1
    foo.value_ = x

  def clear_value(self):
    if foo.has_value_:
      foo.has_value_ = 0
      foo.value_ = ""

  def has_value(self): return foo.has_value_

  def flags(self): return foo.flags_

  def set_flags(self, x):
    foo.has_flags_ = 1
    foo.flags_ = x

  def clear_flags(self):
    if foo.has_flags_:
      foo.has_flags_ = 0
      foo.flags_ = 0

  def has_flags(self): return foo.has_flags_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_key()): foo.set_key(foo.key())
    if (foo.has_value()): foo.set_value(foo.value())
    if (foo.has_flags()): foo.set_flags(foo.flags())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_key_ != foo.has_key_: return 0
    if foo.has_key_ and foo.key_ != foo.key_: return 0
    if foo.has_value_ != foo.has_value_: return 0
    if foo.has_value_ and foo.value_ != foo.value_: return 0
    if foo.has_flags_ != foo.has_flags_: return 0
    if foo.has_flags_ and foo.flags_ != foo.flags_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_key_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: key not set.')
    if (not foo.has_value_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthString(foo(foo.key_))
    n += foo.lengthString(foo(foo.value_))
    if (foo.has_flags_): n += 5
    return n + 2

  def Clear(self):
    foo.clear_key()
    foo.clear_value()
    foo.clear_flags()

  def OutputUnchecked(self, out):
    foo.putVarInt32(18)
    foo.putPrefixedString(foo.key_)
    foo.putVarInt32(26)
    foo.putPrefixedString(foo.value_)
    if (foo.has_flags_):
      foo.putVarInt32(37)
      foo.put32(foo.flags_)

  def TryMerge(self, d):
    while 1:
      tt = foo.getVarInt32()
      if tt == 12: break
      if tt == 18:
        foo.set_key(foo.getPrefixedString())
        continue
      if tt == 26:
        foo.set_value(foo.getPrefixedString())
        continue
      if tt == 37:
        foo.set_flags(foo.get32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_key_: res+=prefix+("key: %s\n" % foo.DebugFormatString(foo.key_))
    if foo.has_value_: res+=prefix+("value: %s\n" % foo.DebugFormatString(foo.value_))
    if foo.has_flags_: res+=prefix+("flags: %s\n" % foo.DebugFormatFixed32(foo.flags_))
    return res

class MemcacheGetResponse(foo.ProtocolMessage):

  def __init__(self, contents=None):
    foo.item_ = []
    if contents is not None: foo.MergeFromString(contents)

  def item_size(self): return foo(foo.item_)
  def item_list(self): return foo.item_

  def item(self, i):
    return foo.item_[i]

  def mutable_item(self, i):
    return foo.item_[i]

  def add_item(self):
    x = foo()
    foo.item_.append(x)
    return x

  def clear_item(self):
    foo.item_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.item_size()): foo.add_item().CopyFrom(foo.item(i))

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.item_) != foo(foo.item_): return 0
    for e1, e2 in foo(foo.item_, foo.item_):
      if e1 != e2: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for p in foo.item_:
      if not foo.IsInitialized(debug_strs): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * foo(foo.item_)
    for i in foo(foo(foo.item_)): n += foo.item_[i].ByteSize()
    return n + 0

  def Clear(self):
    foo.clear_item()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.item_)):
      foo.putVarInt32(11)
      foo.item_[i].OutputUnchecked(out)
      foo.putVarInt32(12)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 11:
        foo.add_item().TryMerge(d)
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Item%s {\n" % elm)
      res+=foo.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kItemGroup = 1
  kItemkey = 2
  kItemvalue = 3
  kItemflags = 4

  _TEXT = foo({
    0: "ErrorCode",
    1: "Item",
    2: "key",
    3: "value",
    4: "flags",
  }, 4)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STARTGROUP,
    2: foo.Encoder.STRING,
    3: foo.Encoder.STRING,
    4: foo.Encoder.FLOAT,
  }, 4, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheSetRequest_Item(foo.ProtocolMessage):
  has_key_ = 0
  key_ = ""
  has_value_ = 0
  value_ = ""
  has_flags_ = 0
  flags_ = 0
  has_set_policy_ = 0
  set_policy_ = 1
  has_expiration_time_ = 0
  expiration_time_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def key(self): return foo.key_

  def set_key(self, x):
    foo.has_key_ = 1
    foo.key_ = x

  def clear_key(self):
    if foo.has_key_:
      foo.has_key_ = 0
      foo.key_ = ""

  def has_key(self): return foo.has_key_

  def value(self): return foo.value_

  def set_value(self, x):
    foo.has_value_ = 1
    foo.value_ = x

  def clear_value(self):
    if foo.has_value_:
      foo.has_value_ = 0
      foo.value_ = ""

  def has_value(self): return foo.has_value_

  def flags(self): return foo.flags_

  def set_flags(self, x):
    foo.has_flags_ = 1
    foo.flags_ = x

  def clear_flags(self):
    if foo.has_flags_:
      foo.has_flags_ = 0
      foo.flags_ = 0

  def has_flags(self): return foo.has_flags_

  def set_policy(self): return foo.set_policy_

  def set_set_policy(self, x):
    foo.has_set_policy_ = 1
    foo.set_policy_ = x

  def clear_set_policy(self):
    if foo.has_set_policy_:
      foo.has_set_policy_ = 0
      foo.set_policy_ = 1

  def has_set_policy(self): return foo.has_set_policy_

  def expiration_time(self): return foo.expiration_time_

  def set_expiration_time(self, x):
    foo.has_expiration_time_ = 1
    foo.expiration_time_ = x

  def clear_expiration_time(self):
    if foo.has_expiration_time_:
      foo.has_expiration_time_ = 0
      foo.expiration_time_ = 0

  def has_expiration_time(self): return foo.has_expiration_time_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_key()): foo.set_key(foo.key())
    if (foo.has_value()): foo.set_value(foo.value())
    if (foo.has_flags()): foo.set_flags(foo.flags())
    if (foo.has_set_policy()): foo.set_set_policy(foo.set_policy())
    if (foo.has_expiration_time()): foo.set_expiration_time(foo.expiration_time())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_key_ != foo.has_key_: return 0
    if foo.has_key_ and foo.key_ != foo.key_: return 0
    if foo.has_value_ != foo.has_value_: return 0
    if foo.has_value_ and foo.value_ != foo.value_: return 0
    if foo.has_flags_ != foo.has_flags_: return 0
    if foo.has_flags_ and foo.flags_ != foo.flags_: return 0
    if foo.has_set_policy_ != foo.has_set_policy_: return 0
    if foo.has_set_policy_ and foo.set_policy_ != foo.set_policy_: return 0
    if foo.has_expiration_time_ != foo.has_expiration_time_: return 0
    if foo.has_expiration_time_ and foo.expiration_time_ != foo.expiration_time_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_key_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: key not set.')
    if (not foo.has_value_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthString(foo(foo.key_))
    n += foo.lengthString(foo(foo.value_))
    if (foo.has_flags_): n += 5
    if (foo.has_set_policy_): n += 1 + foo.lengthVarInt64(foo.set_policy_)
    if (foo.has_expiration_time_): n += 5
    return n + 2

  def Clear(self):
    foo.clear_key()
    foo.clear_value()
    foo.clear_flags()
    foo.clear_set_policy()
    foo.clear_expiration_time()

  def OutputUnchecked(self, out):
    foo.putVarInt32(18)
    foo.putPrefixedString(foo.key_)
    foo.putVarInt32(26)
    foo.putPrefixedString(foo.value_)
    if (foo.has_flags_):
      foo.putVarInt32(37)
      foo.put32(foo.flags_)
    if (foo.has_set_policy_):
      foo.putVarInt32(40)
      foo.putVarInt32(foo.set_policy_)
    if (foo.has_expiration_time_):
      foo.putVarInt32(53)
      foo.put32(foo.expiration_time_)

  def TryMerge(self, d):
    while 1:
      tt = foo.getVarInt32()
      if tt == 12: break
      if tt == 18:
        foo.set_key(foo.getPrefixedString())
        continue
      if tt == 26:
        foo.set_value(foo.getPrefixedString())
        continue
      if tt == 37:
        foo.set_flags(foo.get32())
        continue
      if tt == 40:
        foo.set_set_policy(foo.getVarInt32())
        continue
      if tt == 53:
        foo.set_expiration_time(foo.get32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_key_: res+=prefix+("key: %s\n" % foo.DebugFormatString(foo.key_))
    if foo.has_value_: res+=prefix+("value: %s\n" % foo.DebugFormatString(foo.value_))
    if foo.has_flags_: res+=prefix+("flags: %s\n" % foo.DebugFormatFixed32(foo.flags_))
    if foo.has_set_policy_: res+=prefix+("set_policy: %s\n" % foo.DebugFormatInt32(foo.set_policy_))
    if foo.has_expiration_time_: res+=prefix+("expiration_time: %s\n" % foo.DebugFormatFixed32(foo.expiration_time_))
    return res

class MemcacheSetRequest(foo.ProtocolMessage):

  SET          =    1
  ADD          =    2
  REPLACE      =    3

  _SetPolicy_NAMES = {
    1: "SET",
    2: "ADD",
    3: "REPLACE",
  }

  def SetPolicy_Name(cls, x): return foo._SetPolicy_NAMES.get(x, "")
  SetPolicy_Name = foo(SetPolicy_Name)

  has_name_space_ = 0
  name_space_ = ""

  def __init__(self, contents=None):
    foo.item_ = []
    if contents is not None: foo.MergeFromString(contents)

  def item_size(self): return foo(foo.item_)
  def item_list(self): return foo.item_

  def item(self, i):
    return foo.item_[i]

  def mutable_item(self, i):
    return foo.item_[i]

  def add_item(self):
    x = foo()
    foo.item_.append(x)
    return x

  def clear_item(self):
    foo.item_ = []
  def name_space(self): return foo.name_space_

  def set_name_space(self, x):
    foo.has_name_space_ = 1
    foo.name_space_ = x

  def clear_name_space(self):
    if foo.has_name_space_:
      foo.has_name_space_ = 0
      foo.name_space_ = ""

  def has_name_space(self): return foo.has_name_space_


  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.item_size()): foo.add_item().CopyFrom(foo.item(i))
    if (foo.has_name_space()): foo.set_name_space(foo.name_space())

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.item_) != foo(foo.item_): return 0
    for e1, e2 in foo(foo.item_, foo.item_):
      if e1 != e2: return 0
    if foo.has_name_space_ != foo.has_name_space_: return 0
    if foo.has_name_space_ and foo.name_space_ != foo.name_space_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for p in foo.item_:
      if not foo.IsInitialized(debug_strs): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * foo(foo.item_)
    for i in foo(foo(foo.item_)): n += foo.item_[i].ByteSize()
    if (foo.has_name_space_): n += 1 + foo.lengthString(foo(foo.name_space_))
    return n + 0

  def Clear(self):
    foo.clear_item()
    foo.clear_name_space()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.item_)):
      foo.putVarInt32(11)
      foo.item_[i].OutputUnchecked(out)
      foo.putVarInt32(12)
    if (foo.has_name_space_):
      foo.putVarInt32(58)
      foo.putPrefixedString(foo.name_space_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 11:
        foo.add_item().TryMerge(d)
        continue
      if tt == 58:
        foo.set_name_space(foo.getPrefixedString())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Item%s {\n" % elm)
      res+=foo.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if foo.has_name_space_: res+=prefix+("name_space: %s\n" % foo.DebugFormatString(foo.name_space_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kItemGroup = 1
  kItemkey = 2
  kItemvalue = 3
  kItemflags = 4
  kItemset_policy = 5
  kItemexpiration_time = 6
  kname_space = 7

  _TEXT = foo({
    0: "ErrorCode",
    1: "Item",
    2: "key",
    3: "value",
    4: "flags",
    5: "set_policy",
    6: "expiration_time",
    7: "name_space",
  }, 7)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STARTGROUP,
    2: foo.Encoder.STRING,
    3: foo.Encoder.STRING,
    4: foo.Encoder.FLOAT,
    5: foo.Encoder.NUMERIC,
    6: foo.Encoder.FLOAT,
    7: foo.Encoder.STRING,
  }, 7, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheSetResponse(foo.ProtocolMessage):

  STORED       =    1
  NOT_STORED   =    2
  ERROR        =    3

  _SetStatusCode_NAMES = {
    1: "STORED",
    2: "NOT_STORED",
    3: "ERROR",
  }

  def SetStatusCode_Name(cls, x): return foo._SetStatusCode_NAMES.get(x, "")
  SetStatusCode_Name = foo(SetStatusCode_Name)


  def __init__(self, contents=None):
    foo.set_status_ = []
    if contents is not None: foo.MergeFromString(contents)

  def set_status_size(self): return foo(foo.set_status_)
  def set_status_list(self): return foo.set_status_

  def set_status(self, i):
    return foo.set_status_[i]

  def set_set_status(self, i, x):
    foo.set_status_[i] = x

  def add_set_status(self, x):
    foo.set_status_.append(x)

  def clear_set_status(self):
    foo.set_status_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.set_status_size()): foo.add_set_status(foo.set_status(i))

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.set_status_) != foo(foo.set_status_): return 0
    for e1, e2 in foo(foo.set_status_, foo.set_status_):
      if e1 != e2: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * foo(foo.set_status_)
    for i in foo(foo(foo.set_status_)): n += foo.lengthVarInt64(foo.set_status_[i])
    return n + 0

  def Clear(self):
    foo.clear_set_status()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.set_status_)):
      foo.putVarInt32(8)
      foo.putVarInt32(foo.set_status_[i])

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 8:
        foo.add_set_status(foo.getVarInt32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.set_status_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("set_status%s: %s\n" % (elm, foo.DebugFormatInt32(e)))
      cnt+=1
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kset_status = 1

  _TEXT = foo({
    0: "ErrorCode",
    1: "set_status",
  }, 1)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.NUMERIC,
  }, 1, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheDeleteRequest_Item(foo.ProtocolMessage):
  has_key_ = 0
  key_ = ""
  has_delete_time_ = 0
  delete_time_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def key(self): return foo.key_

  def set_key(self, x):
    foo.has_key_ = 1
    foo.key_ = x

  def clear_key(self):
    if foo.has_key_:
      foo.has_key_ = 0
      foo.key_ = ""

  def has_key(self): return foo.has_key_

  def delete_time(self): return foo.delete_time_

  def set_delete_time(self, x):
    foo.has_delete_time_ = 1
    foo.delete_time_ = x

  def clear_delete_time(self):
    if foo.has_delete_time_:
      foo.has_delete_time_ = 0
      foo.delete_time_ = 0

  def has_delete_time(self): return foo.has_delete_time_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_key()): foo.set_key(foo.key())
    if (foo.has_delete_time()): foo.set_delete_time(foo.delete_time())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_key_ != foo.has_key_: return 0
    if foo.has_key_ and foo.key_ != foo.key_: return 0
    if foo.has_delete_time_ != foo.has_delete_time_: return 0
    if foo.has_delete_time_ and foo.delete_time_ != foo.delete_time_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_key_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: key not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthString(foo(foo.key_))
    if (foo.has_delete_time_): n += 5
    return n + 1

  def Clear(self):
    foo.clear_key()
    foo.clear_delete_time()

  def OutputUnchecked(self, out):
    foo.putVarInt32(18)
    foo.putPrefixedString(foo.key_)
    if (foo.has_delete_time_):
      foo.putVarInt32(29)
      foo.put32(foo.delete_time_)

  def TryMerge(self, d):
    while 1:
      tt = foo.getVarInt32()
      if tt == 12: break
      if tt == 18:
        foo.set_key(foo.getPrefixedString())
        continue
      if tt == 29:
        foo.set_delete_time(foo.get32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_key_: res+=prefix+("key: %s\n" % foo.DebugFormatString(foo.key_))
    if foo.has_delete_time_: res+=prefix+("delete_time: %s\n" % foo.DebugFormatFixed32(foo.delete_time_))
    return res

class MemcacheDeleteRequest(foo.ProtocolMessage):
  has_name_space_ = 0
  name_space_ = ""

  def __init__(self, contents=None):
    foo.item_ = []
    if contents is not None: foo.MergeFromString(contents)

  def item_size(self): return foo(foo.item_)
  def item_list(self): return foo.item_

  def item(self, i):
    return foo.item_[i]

  def mutable_item(self, i):
    return foo.item_[i]

  def add_item(self):
    x = foo()
    foo.item_.append(x)
    return x

  def clear_item(self):
    foo.item_ = []
  def name_space(self): return foo.name_space_

  def set_name_space(self, x):
    foo.has_name_space_ = 1
    foo.name_space_ = x

  def clear_name_space(self):
    if foo.has_name_space_:
      foo.has_name_space_ = 0
      foo.name_space_ = ""

  def has_name_space(self): return foo.has_name_space_


  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.item_size()): foo.add_item().CopyFrom(foo.item(i))
    if (foo.has_name_space()): foo.set_name_space(foo.name_space())

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.item_) != foo(foo.item_): return 0
    for e1, e2 in foo(foo.item_, foo.item_):
      if e1 != e2: return 0
    if foo.has_name_space_ != foo.has_name_space_: return 0
    if foo.has_name_space_ and foo.name_space_ != foo.name_space_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for p in foo.item_:
      if not foo.IsInitialized(debug_strs): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * foo(foo.item_)
    for i in foo(foo(foo.item_)): n += foo.item_[i].ByteSize()
    if (foo.has_name_space_): n += 1 + foo.lengthString(foo(foo.name_space_))
    return n + 0

  def Clear(self):
    foo.clear_item()
    foo.clear_name_space()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.item_)):
      foo.putVarInt32(11)
      foo.item_[i].OutputUnchecked(out)
      foo.putVarInt32(12)
    if (foo.has_name_space_):
      foo.putVarInt32(34)
      foo.putPrefixedString(foo.name_space_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 11:
        foo.add_item().TryMerge(d)
        continue
      if tt == 34:
        foo.set_name_space(foo.getPrefixedString())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Item%s {\n" % elm)
      res+=foo.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    if foo.has_name_space_: res+=prefix+("name_space: %s\n" % foo.DebugFormatString(foo.name_space_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kItemGroup = 1
  kItemkey = 2
  kItemdelete_time = 3
  kname_space = 4

  _TEXT = foo({
    0: "ErrorCode",
    1: "Item",
    2: "key",
    3: "delete_time",
    4: "name_space",
  }, 4)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STARTGROUP,
    2: foo.Encoder.STRING,
    3: foo.Encoder.FLOAT,
    4: foo.Encoder.STRING,
  }, 4, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheDeleteResponse(foo.ProtocolMessage):

  DELETED      =    1
  NOT_FOUND    =    2

  _DeleteStatusCode_NAMES = {
    1: "DELETED",
    2: "NOT_FOUND",
  }

  def DeleteStatusCode_Name(cls, x): return foo._DeleteStatusCode_NAMES.get(x, "")
  DeleteStatusCode_Name = foo(DeleteStatusCode_Name)


  def __init__(self, contents=None):
    foo.delete_status_ = []
    if contents is not None: foo.MergeFromString(contents)

  def delete_status_size(self): return foo(foo.delete_status_)
  def delete_status_list(self): return foo.delete_status_

  def delete_status(self, i):
    return foo.delete_status_[i]

  def set_delete_status(self, i, x):
    foo.delete_status_[i] = x

  def add_delete_status(self, x):
    foo.delete_status_.append(x)

  def clear_delete_status(self):
    foo.delete_status_ = []


  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.delete_status_size()): foo.add_delete_status(foo.delete_status(i))

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.delete_status_) != foo(foo.delete_status_): return 0
    for e1, e2 in foo(foo.delete_status_, foo.delete_status_):
      if e1 != e2: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * foo(foo.delete_status_)
    for i in foo(foo(foo.delete_status_)): n += foo.lengthVarInt64(foo.delete_status_[i])
    return n + 0

  def Clear(self):
    foo.clear_delete_status()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.delete_status_)):
      foo.putVarInt32(8)
      foo.putVarInt32(foo.delete_status_[i])

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 8:
        foo.add_delete_status(foo.getVarInt32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.delete_status_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("delete_status%s: %s\n" % (elm, foo.DebugFormatInt32(e)))
      cnt+=1
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kdelete_status = 1

  _TEXT = foo({
    0: "ErrorCode",
    1: "delete_status",
  }, 1)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.NUMERIC,
  }, 1, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheIncrementRequest(foo.ProtocolMessage):

  INCREMENT    =    1
  DECREMENT    =    2

  _Direction_NAMES = {
    1: "INCREMENT",
    2: "DECREMENT",
  }

  def Direction_Name(cls, x): return foo._Direction_NAMES.get(x, "")
  Direction_Name = foo(Direction_Name)

  has_key_ = 0
  key_ = ""
  has_name_space_ = 0
  name_space_ = ""
  has_delta_ = 0
  delta_ = 1
  has_direction_ = 0
  direction_ = 1
  has_initial_value_ = 0
  initial_value_ = 0
  has_initial_flags_ = 0
  initial_flags_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def key(self): return foo.key_

  def set_key(self, x):
    foo.has_key_ = 1
    foo.key_ = x

  def clear_key(self):
    if foo.has_key_:
      foo.has_key_ = 0
      foo.key_ = ""

  def has_key(self): return foo.has_key_

  def name_space(self): return foo.name_space_

  def set_name_space(self, x):
    foo.has_name_space_ = 1
    foo.name_space_ = x

  def clear_name_space(self):
    if foo.has_name_space_:
      foo.has_name_space_ = 0
      foo.name_space_ = ""

  def has_name_space(self): return foo.has_name_space_

  def delta(self): return foo.delta_

  def set_delta(self, x):
    foo.has_delta_ = 1
    foo.delta_ = x

  def clear_delta(self):
    if foo.has_delta_:
      foo.has_delta_ = 0
      foo.delta_ = 1

  def has_delta(self): return foo.has_delta_

  def direction(self): return foo.direction_

  def set_direction(self, x):
    foo.has_direction_ = 1
    foo.direction_ = x

  def clear_direction(self):
    if foo.has_direction_:
      foo.has_direction_ = 0
      foo.direction_ = 1

  def has_direction(self): return foo.has_direction_

  def initial_value(self): return foo.initial_value_

  def set_initial_value(self, x):
    foo.has_initial_value_ = 1
    foo.initial_value_ = x

  def clear_initial_value(self):
    if foo.has_initial_value_:
      foo.has_initial_value_ = 0
      foo.initial_value_ = 0

  def has_initial_value(self): return foo.has_initial_value_

  def initial_flags(self): return foo.initial_flags_

  def set_initial_flags(self, x):
    foo.has_initial_flags_ = 1
    foo.initial_flags_ = x

  def clear_initial_flags(self):
    if foo.has_initial_flags_:
      foo.has_initial_flags_ = 0
      foo.initial_flags_ = 0

  def has_initial_flags(self): return foo.has_initial_flags_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_key()): foo.set_key(foo.key())
    if (foo.has_name_space()): foo.set_name_space(foo.name_space())
    if (foo.has_delta()): foo.set_delta(foo.delta())
    if (foo.has_direction()): foo.set_direction(foo.direction())
    if (foo.has_initial_value()): foo.set_initial_value(foo.initial_value())
    if (foo.has_initial_flags()): foo.set_initial_flags(foo.initial_flags())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_key_ != foo.has_key_: return 0
    if foo.has_key_ and foo.key_ != foo.key_: return 0
    if foo.has_name_space_ != foo.has_name_space_: return 0
    if foo.has_name_space_ and foo.name_space_ != foo.name_space_: return 0
    if foo.has_delta_ != foo.has_delta_: return 0
    if foo.has_delta_ and foo.delta_ != foo.delta_: return 0
    if foo.has_direction_ != foo.has_direction_: return 0
    if foo.has_direction_ and foo.direction_ != foo.direction_: return 0
    if foo.has_initial_value_ != foo.has_initial_value_: return 0
    if foo.has_initial_value_ and foo.initial_value_ != foo.initial_value_: return 0
    if foo.has_initial_flags_ != foo.has_initial_flags_: return 0
    if foo.has_initial_flags_ and foo.initial_flags_ != foo.initial_flags_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_key_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: key not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthString(foo(foo.key_))
    if (foo.has_name_space_): n += 1 + foo.lengthString(foo(foo.name_space_))
    if (foo.has_delta_): n += 1 + foo.lengthVarInt64(foo.delta_)
    if (foo.has_direction_): n += 1 + foo.lengthVarInt64(foo.direction_)
    if (foo.has_initial_value_): n += 1 + foo.lengthVarInt64(foo.initial_value_)
    if (foo.has_initial_flags_): n += 5
    return n + 1

  def Clear(self):
    foo.clear_key()
    foo.clear_name_space()
    foo.clear_delta()
    foo.clear_direction()
    foo.clear_initial_value()
    foo.clear_initial_flags()

  def OutputUnchecked(self, out):
    foo.putVarInt32(10)
    foo.putPrefixedString(foo.key_)
    if (foo.has_delta_):
      foo.putVarInt32(16)
      foo.putVarUint64(foo.delta_)
    if (foo.has_direction_):
      foo.putVarInt32(24)
      foo.putVarInt32(foo.direction_)
    if (foo.has_name_space_):
      foo.putVarInt32(34)
      foo.putPrefixedString(foo.name_space_)
    if (foo.has_initial_value_):
      foo.putVarInt32(40)
      foo.putVarUint64(foo.initial_value_)
    if (foo.has_initial_flags_):
      foo.putVarInt32(53)
      foo.put32(foo.initial_flags_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 10:
        foo.set_key(foo.getPrefixedString())
        continue
      if tt == 16:
        foo.set_delta(foo.getVarUint64())
        continue
      if tt == 24:
        foo.set_direction(foo.getVarInt32())
        continue
      if tt == 34:
        foo.set_name_space(foo.getPrefixedString())
        continue
      if tt == 40:
        foo.set_initial_value(foo.getVarUint64())
        continue
      if tt == 53:
        foo.set_initial_flags(foo.get32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_key_: res+=prefix+("key: %s\n" % foo.DebugFormatString(foo.key_))
    if foo.has_name_space_: res+=prefix+("name_space: %s\n" % foo.DebugFormatString(foo.name_space_))
    if foo.has_delta_: res+=prefix+("delta: %s\n" % foo.DebugFormatInt64(foo.delta_))
    if foo.has_direction_: res+=prefix+("direction: %s\n" % foo.DebugFormatInt32(foo.direction_))
    if foo.has_initial_value_: res+=prefix+("initial_value: %s\n" % foo.DebugFormatInt64(foo.initial_value_))
    if foo.has_initial_flags_: res+=prefix+("initial_flags: %s\n" % foo.DebugFormatFixed32(foo.initial_flags_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kkey = 1
  kname_space = 4
  kdelta = 2
  kdirection = 3
  kinitial_value = 5
  kinitial_flags = 6

  _TEXT = foo({
    0: "ErrorCode",
    1: "key",
    2: "delta",
    3: "direction",
    4: "name_space",
    5: "initial_value",
    6: "initial_flags",
  }, 6)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STRING,
    2: foo.Encoder.NUMERIC,
    3: foo.Encoder.NUMERIC,
    4: foo.Encoder.STRING,
    5: foo.Encoder.NUMERIC,
    6: foo.Encoder.FLOAT,
  }, 6, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheIncrementResponse(foo.ProtocolMessage):

  OK           =    1
  NOT_CHANGED  =    2
  ERROR        =    3

  _IncrementStatusCode_NAMES = {
    1: "OK",
    2: "NOT_CHANGED",
    3: "ERROR",
  }

  def IncrementStatusCode_Name(cls, x): return foo._IncrementStatusCode_NAMES.get(x, "")
  IncrementStatusCode_Name = foo(IncrementStatusCode_Name)

  has_new_value_ = 0
  new_value_ = 0
  has_increment_status_ = 0
  increment_status_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def new_value(self): return foo.new_value_

  def set_new_value(self, x):
    foo.has_new_value_ = 1
    foo.new_value_ = x

  def clear_new_value(self):
    if foo.has_new_value_:
      foo.has_new_value_ = 0
      foo.new_value_ = 0

  def has_new_value(self): return foo.has_new_value_

  def increment_status(self): return foo.increment_status_

  def set_increment_status(self, x):
    foo.has_increment_status_ = 1
    foo.increment_status_ = x

  def clear_increment_status(self):
    if foo.has_increment_status_:
      foo.has_increment_status_ = 0
      foo.increment_status_ = 0

  def has_increment_status(self): return foo.has_increment_status_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_new_value()): foo.set_new_value(foo.new_value())
    if (foo.has_increment_status()): foo.set_increment_status(foo.increment_status())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_new_value_ != foo.has_new_value_: return 0
    if foo.has_new_value_ and foo.new_value_ != foo.new_value_: return 0
    if foo.has_increment_status_ != foo.has_increment_status_: return 0
    if foo.has_increment_status_ and foo.increment_status_ != foo.increment_status_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    if (foo.has_new_value_): n += 1 + foo.lengthVarInt64(foo.new_value_)
    if (foo.has_increment_status_): n += 1 + foo.lengthVarInt64(foo.increment_status_)
    return n + 0

  def Clear(self):
    foo.clear_new_value()
    foo.clear_increment_status()

  def OutputUnchecked(self, out):
    if (foo.has_new_value_):
      foo.putVarInt32(8)
      foo.putVarUint64(foo.new_value_)
    if (foo.has_increment_status_):
      foo.putVarInt32(16)
      foo.putVarInt32(foo.increment_status_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 8:
        foo.set_new_value(foo.getVarUint64())
        continue
      if tt == 16:
        foo.set_increment_status(foo.getVarInt32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_new_value_: res+=prefix+("new_value: %s\n" % foo.DebugFormatInt64(foo.new_value_))
    if foo.has_increment_status_: res+=prefix+("increment_status: %s\n" % foo.DebugFormatInt32(foo.increment_status_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  knew_value = 1
  kincrement_status = 2

  _TEXT = foo({
    0: "ErrorCode",
    1: "new_value",
    2: "increment_status",
  }, 2)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.NUMERIC,
    2: foo.Encoder.NUMERIC,
  }, 2, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheBatchIncrementRequest(foo.ProtocolMessage):
  has_name_space_ = 0
  name_space_ = ""

  def __init__(self, contents=None):
    foo.item_ = []
    if contents is not None: foo.MergeFromString(contents)

  def name_space(self): return foo.name_space_

  def set_name_space(self, x):
    foo.has_name_space_ = 1
    foo.name_space_ = x

  def clear_name_space(self):
    if foo.has_name_space_:
      foo.has_name_space_ = 0
      foo.name_space_ = ""

  def has_name_space(self): return foo.has_name_space_

  def item_size(self): return foo(foo.item_)
  def item_list(self): return foo.item_

  def item(self, i):
    return foo.item_[i]

  def mutable_item(self, i):
    return foo.item_[i]

  def add_item(self):
    x = foo()
    foo.item_.append(x)
    return x

  def clear_item(self):
    foo.item_ = []

  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_name_space()): foo.set_name_space(foo.name_space())
    for i in foo(foo.item_size()): foo.add_item().CopyFrom(foo.item(i))

  def Equals(self, x):
    if x is self: return 1
    if foo.has_name_space_ != foo.has_name_space_: return 0
    if foo.has_name_space_ and foo.name_space_ != foo.name_space_: return 0
    if foo(foo.item_) != foo(foo.item_): return 0
    for e1, e2 in foo(foo.item_, foo.item_):
      if e1 != e2: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for p in foo.item_:
      if not foo.IsInitialized(debug_strs): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    if (foo.has_name_space_): n += 1 + foo.lengthString(foo(foo.name_space_))
    n += 1 * foo(foo.item_)
    for i in foo(foo(foo.item_)): n += foo.lengthString(foo.item_[i].ByteSize())
    return n + 0

  def Clear(self):
    foo.clear_name_space()
    foo.clear_item()

  def OutputUnchecked(self, out):
    if (foo.has_name_space_):
      foo.putVarInt32(10)
      foo.putPrefixedString(foo.name_space_)
    for i in foo(foo(foo.item_)):
      foo.putVarInt32(18)
      foo.putVarInt32(foo.item_[i].ByteSize())
      foo.item_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 10:
        foo.set_name_space(foo.getPrefixedString())
        continue
      if tt == 18:
        length = foo.getVarInt32()
        tmp = foo.Decoder(foo.buffer(), foo.pos(), foo.pos() + length)
        foo.skip(length)
        foo.add_item().TryMerge(tmp)
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_name_space_: res+=prefix+("name_space: %s\n" % foo.DebugFormatString(foo.name_space_))
    cnt=0
    for e in foo.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("item%s <\n" % elm)
      res+=foo.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kname_space = 1
  kitem = 2

  _TEXT = foo({
    0: "ErrorCode",
    1: "name_space",
    2: "item",
  }, 2)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STRING,
    2: foo.Encoder.STRING,
  }, 2, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheBatchIncrementResponse(foo.ProtocolMessage):

  def __init__(self, contents=None):
    foo.item_ = []
    if contents is not None: foo.MergeFromString(contents)

  def item_size(self): return foo(foo.item_)
  def item_list(self): return foo.item_

  def item(self, i):
    return foo.item_[i]

  def mutable_item(self, i):
    return foo.item_[i]

  def add_item(self):
    x = foo()
    foo.item_.append(x)
    return x

  def clear_item(self):
    foo.item_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.item_size()): foo.add_item().CopyFrom(foo.item(i))

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.item_) != foo(foo.item_): return 0
    for e1, e2 in foo(foo.item_, foo.item_):
      if e1 != e2: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for p in foo.item_:
      if not foo.IsInitialized(debug_strs): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 1 * foo(foo.item_)
    for i in foo(foo(foo.item_)): n += foo.lengthString(foo.item_[i].ByteSize())
    return n + 0

  def Clear(self):
    foo.clear_item()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.item_)):
      foo.putVarInt32(10)
      foo.putVarInt32(foo.item_[i].ByteSize())
      foo.item_[i].OutputUnchecked(out)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 10:
        length = foo.getVarInt32()
        tmp = foo.Decoder(foo.buffer(), foo.pos(), foo.pos() + length)
        foo.skip(length)
        foo.add_item().TryMerge(tmp)
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("item%s <\n" % elm)
      res+=foo.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
      cnt+=1
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kitem = 1

  _TEXT = foo({
    0: "ErrorCode",
    1: "item",
  }, 1)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STRING,
  }, 1, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheFlushRequest(foo.ProtocolMessage):

  def __init__(self, contents=None):
    pass
    if contents is not None: foo.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def Equals(self, x):
    if x is self: return 1
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])


  _TEXT = foo({
    0: "ErrorCode",
  }, 0)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
  }, 0, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheFlushResponse(foo.ProtocolMessage):

  def __init__(self, contents=None):
    pass
    if contents is not None: foo.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def Equals(self, x):
    if x is self: return 1
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])


  _TEXT = foo({
    0: "ErrorCode",
  }, 0)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
  }, 0, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheStatsRequest(foo.ProtocolMessage):

  def __init__(self, contents=None):
    pass
    if contents is not None: foo.MergeFromString(contents)


  def MergeFrom(self, x):
    assert x is not self

  def Equals(self, x):
    if x is self: return 1
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    return initialized

  def ByteSize(self):
    n = 0
    return n + 0

  def Clear(self):
    pass

  def OutputUnchecked(self, out):
    pass

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])


  _TEXT = foo({
    0: "ErrorCode",
  }, 0)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
  }, 0, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MergedNamespaceStats(foo.ProtocolMessage):
  has_hits_ = 0
  hits_ = 0
  has_misses_ = 0
  misses_ = 0
  has_byte_hits_ = 0
  byte_hits_ = 0
  has_items_ = 0
  items_ = 0
  has_bytes_ = 0
  bytes_ = 0
  has_oldest_item_age_ = 0
  oldest_item_age_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def hits(self): return foo.hits_

  def set_hits(self, x):
    foo.has_hits_ = 1
    foo.hits_ = x

  def clear_hits(self):
    if foo.has_hits_:
      foo.has_hits_ = 0
      foo.hits_ = 0

  def has_hits(self): return foo.has_hits_

  def misses(self): return foo.misses_

  def set_misses(self, x):
    foo.has_misses_ = 1
    foo.misses_ = x

  def clear_misses(self):
    if foo.has_misses_:
      foo.has_misses_ = 0
      foo.misses_ = 0

  def has_misses(self): return foo.has_misses_

  def byte_hits(self): return foo.byte_hits_

  def set_byte_hits(self, x):
    foo.has_byte_hits_ = 1
    foo.byte_hits_ = x

  def clear_byte_hits(self):
    if foo.has_byte_hits_:
      foo.has_byte_hits_ = 0
      foo.byte_hits_ = 0

  def has_byte_hits(self): return foo.has_byte_hits_

  def items(self): return foo.items_

  def set_items(self, x):
    foo.has_items_ = 1
    foo.items_ = x

  def clear_items(self):
    if foo.has_items_:
      foo.has_items_ = 0
      foo.items_ = 0

  def has_items(self): return foo.has_items_

  def bytes(self): return foo.bytes_

  def set_bytes(self, x):
    foo.has_bytes_ = 1
    foo.bytes_ = x

  def clear_bytes(self):
    if foo.has_bytes_:
      foo.has_bytes_ = 0
      foo.bytes_ = 0

  def has_bytes(self): return foo.has_bytes_

  def oldest_item_age(self): return foo.oldest_item_age_

  def set_oldest_item_age(self, x):
    foo.has_oldest_item_age_ = 1
    foo.oldest_item_age_ = x

  def clear_oldest_item_age(self):
    if foo.has_oldest_item_age_:
      foo.has_oldest_item_age_ = 0
      foo.oldest_item_age_ = 0

  def has_oldest_item_age(self): return foo.has_oldest_item_age_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_hits()): foo.set_hits(foo.hits())
    if (foo.has_misses()): foo.set_misses(foo.misses())
    if (foo.has_byte_hits()): foo.set_byte_hits(foo.byte_hits())
    if (foo.has_items()): foo.set_items(foo.items())
    if (foo.has_bytes()): foo.set_bytes(foo.bytes())
    if (foo.has_oldest_item_age()): foo.set_oldest_item_age(foo.oldest_item_age())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_hits_ != foo.has_hits_: return 0
    if foo.has_hits_ and foo.hits_ != foo.hits_: return 0
    if foo.has_misses_ != foo.has_misses_: return 0
    if foo.has_misses_ and foo.misses_ != foo.misses_: return 0
    if foo.has_byte_hits_ != foo.has_byte_hits_: return 0
    if foo.has_byte_hits_ and foo.byte_hits_ != foo.byte_hits_: return 0
    if foo.has_items_ != foo.has_items_: return 0
    if foo.has_items_ and foo.items_ != foo.items_: return 0
    if foo.has_bytes_ != foo.has_bytes_: return 0
    if foo.has_bytes_ and foo.bytes_ != foo.bytes_: return 0
    if foo.has_oldest_item_age_ != foo.has_oldest_item_age_: return 0
    if foo.has_oldest_item_age_ and foo.oldest_item_age_ != foo.oldest_item_age_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_hits_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: hits not set.')
    if (not foo.has_misses_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: misses not set.')
    if (not foo.has_byte_hits_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: byte_hits not set.')
    if (not foo.has_items_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: items not set.')
    if (not foo.has_bytes_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: bytes not set.')
    if (not foo.has_oldest_item_age_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: oldest_item_age not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthVarInt64(foo.hits_)
    n += foo.lengthVarInt64(foo.misses_)
    n += foo.lengthVarInt64(foo.byte_hits_)
    n += foo.lengthVarInt64(foo.items_)
    n += foo.lengthVarInt64(foo.bytes_)
    return n + 10

  def Clear(self):
    foo.clear_hits()
    foo.clear_misses()
    foo.clear_byte_hits()
    foo.clear_items()
    foo.clear_bytes()
    foo.clear_oldest_item_age()

  def OutputUnchecked(self, out):
    foo.putVarInt32(8)
    foo.putVarUint64(foo.hits_)
    foo.putVarInt32(16)
    foo.putVarUint64(foo.misses_)
    foo.putVarInt32(24)
    foo.putVarUint64(foo.byte_hits_)
    foo.putVarInt32(32)
    foo.putVarUint64(foo.items_)
    foo.putVarInt32(40)
    foo.putVarUint64(foo.bytes_)
    foo.putVarInt32(53)
    foo.put32(foo.oldest_item_age_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 8:
        foo.set_hits(foo.getVarUint64())
        continue
      if tt == 16:
        foo.set_misses(foo.getVarUint64())
        continue
      if tt == 24:
        foo.set_byte_hits(foo.getVarUint64())
        continue
      if tt == 32:
        foo.set_items(foo.getVarUint64())
        continue
      if tt == 40:
        foo.set_bytes(foo.getVarUint64())
        continue
      if tt == 53:
        foo.set_oldest_item_age(foo.get32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_hits_: res+=prefix+("hits: %s\n" % foo.DebugFormatInt64(foo.hits_))
    if foo.has_misses_: res+=prefix+("misses: %s\n" % foo.DebugFormatInt64(foo.misses_))
    if foo.has_byte_hits_: res+=prefix+("byte_hits: %s\n" % foo.DebugFormatInt64(foo.byte_hits_))
    if foo.has_items_: res+=prefix+("items: %s\n" % foo.DebugFormatInt64(foo.items_))
    if foo.has_bytes_: res+=prefix+("bytes: %s\n" % foo.DebugFormatInt64(foo.bytes_))
    if foo.has_oldest_item_age_: res+=prefix+("oldest_item_age: %s\n" % foo.DebugFormatFixed32(foo.oldest_item_age_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  khits = 1
  kmisses = 2
  kbyte_hits = 3
  kitems = 4
  kbytes = 5
  koldest_item_age = 6

  _TEXT = foo({
    0: "ErrorCode",
    1: "hits",
    2: "misses",
    3: "byte_hits",
    4: "items",
    5: "bytes",
    6: "oldest_item_age",
  }, 6)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.NUMERIC,
    2: foo.Encoder.NUMERIC,
    3: foo.Encoder.NUMERIC,
    4: foo.Encoder.NUMERIC,
    5: foo.Encoder.NUMERIC,
    6: foo.Encoder.FLOAT,
  }, 6, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheStatsResponse(foo.ProtocolMessage):
  has_stats_ = 0
  stats_ = None

  def __init__(self, contents=None):
    foo.lazy_init_lock_ = foo.allocate_lock()
    if contents is not None: foo.MergeFromString(contents)

  def stats(self):
    if foo.stats_ is None:
      foo.lazy_init_lock_.acquire()
      try:
        if foo.stats_ is None: foo.stats_ = foo()
      finally:
        foo.lazy_init_lock_.release()
    return foo.stats_

  def mutable_stats(self): foo.has_stats_ = 1; return foo.stats()

  def clear_stats(self):
    if foo.has_stats_:
      foo.has_stats_ = 0;
      if foo.stats_ is not None: foo.stats_.Clear()

  def has_stats(self): return foo.has_stats_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_stats()): foo.mutable_stats().MergeFrom(foo.stats())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_stats_ != foo.has_stats_: return 0
    if foo.has_stats_ and foo.stats_ != foo.stats_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (foo.has_stats_ and not foo.stats_.IsInitialized(debug_strs)): initialized = 0
    return initialized

  def ByteSize(self):
    n = 0
    if (foo.has_stats_): n += 1 + foo.lengthString(foo.stats_.ByteSize())
    return n + 0

  def Clear(self):
    foo.clear_stats()

  def OutputUnchecked(self, out):
    if (foo.has_stats_):
      foo.putVarInt32(10)
      foo.putVarInt32(foo.stats_.ByteSize())
      foo.stats_.OutputUnchecked(out)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 10:
        length = foo.getVarInt32()
        tmp = foo.Decoder(foo.buffer(), foo.pos(), foo.pos() + length)
        foo.skip(length)
        foo.mutable_stats().TryMerge(tmp)
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_stats_:
      res+=prefix+"stats <\n"
      res+=foo.stats_.__str__(prefix + "  ", printElemNumber)
      res+=prefix+">\n"
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kstats = 1

  _TEXT = foo({
    0: "ErrorCode",
    1: "stats",
  }, 1)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STRING,
  }, 1, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheGrabTailRequest(foo.ProtocolMessage):
  has_item_count_ = 0
  item_count_ = 0
  has_name_space_ = 0
  name_space_ = ""

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def item_count(self): return foo.item_count_

  def set_item_count(self, x):
    foo.has_item_count_ = 1
    foo.item_count_ = x

  def clear_item_count(self):
    if foo.has_item_count_:
      foo.has_item_count_ = 0
      foo.item_count_ = 0

  def has_item_count(self): return foo.has_item_count_

  def name_space(self): return foo.name_space_

  def set_name_space(self, x):
    foo.has_name_space_ = 1
    foo.name_space_ = x

  def clear_name_space(self):
    if foo.has_name_space_:
      foo.has_name_space_ = 0
      foo.name_space_ = ""

  def has_name_space(self): return foo.has_name_space_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_item_count()): foo.set_item_count(foo.item_count())
    if (foo.has_name_space()): foo.set_name_space(foo.name_space())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_item_count_ != foo.has_item_count_: return 0
    if foo.has_item_count_ and foo.item_count_ != foo.item_count_: return 0
    if foo.has_name_space_ != foo.has_name_space_: return 0
    if foo.has_name_space_ and foo.name_space_ != foo.name_space_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_item_count_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: item_count not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthVarInt64(foo.item_count_)
    if (foo.has_name_space_): n += 1 + foo.lengthString(foo(foo.name_space_))
    return n + 1

  def Clear(self):
    foo.clear_item_count()
    foo.clear_name_space()

  def OutputUnchecked(self, out):
    foo.putVarInt32(8)
    foo.putVarInt32(foo.item_count_)
    if (foo.has_name_space_):
      foo.putVarInt32(18)
      foo.putPrefixedString(foo.name_space_)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 8:
        foo.set_item_count(foo.getVarInt32())
        continue
      if tt == 18:
        foo.set_name_space(foo.getPrefixedString())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_item_count_: res+=prefix+("item_count: %s\n" % foo.DebugFormatInt32(foo.item_count_))
    if foo.has_name_space_: res+=prefix+("name_space: %s\n" % foo.DebugFormatString(foo.name_space_))
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kitem_count = 1
  kname_space = 2

  _TEXT = foo({
    0: "ErrorCode",
    1: "item_count",
    2: "name_space",
  }, 2)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.NUMERIC,
    2: foo.Encoder.STRING,
  }, 2, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""
class MemcacheGrabTailResponse_Item(foo.ProtocolMessage):
  has_value_ = 0
  value_ = ""
  has_flags_ = 0
  flags_ = 0

  def __init__(self, contents=None):
    if contents is not None: foo.MergeFromString(contents)

  def value(self): return foo.value_

  def set_value(self, x):
    foo.has_value_ = 1
    foo.value_ = x

  def clear_value(self):
    if foo.has_value_:
      foo.has_value_ = 0
      foo.value_ = ""

  def has_value(self): return foo.has_value_

  def flags(self): return foo.flags_

  def set_flags(self, x):
    foo.has_flags_ = 1
    foo.flags_ = x

  def clear_flags(self):
    if foo.has_flags_:
      foo.has_flags_ = 0
      foo.flags_ = 0

  def has_flags(self): return foo.has_flags_


  def MergeFrom(self, x):
    assert x is not self
    if (foo.has_value()): foo.set_value(foo.value())
    if (foo.has_flags()): foo.set_flags(foo.flags())

  def Equals(self, x):
    if x is self: return 1
    if foo.has_value_ != foo.has_value_: return 0
    if foo.has_value_ and foo.value_ != foo.value_: return 0
    if foo.has_flags_ != foo.has_flags_: return 0
    if foo.has_flags_ and foo.flags_ != foo.flags_: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    if (not foo.has_value_):
      initialized = 0
      if debug_strs is not None:
        foo.append('Required field: value not set.')
    return initialized

  def ByteSize(self):
    n = 0
    n += foo.lengthString(foo(foo.value_))
    if (foo.has_flags_): n += 5
    return n + 1

  def Clear(self):
    foo.clear_value()
    foo.clear_flags()

  def OutputUnchecked(self, out):
    foo.putVarInt32(18)
    foo.putPrefixedString(foo.value_)
    if (foo.has_flags_):
      foo.putVarInt32(29)
      foo.put32(foo.flags_)

  def TryMerge(self, d):
    while 1:
      tt = foo.getVarInt32()
      if tt == 12: break
      if tt == 18:
        foo.set_value(foo.getPrefixedString())
        continue
      if tt == 29:
        foo.set_flags(foo.get32())
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    if foo.has_value_: res+=prefix+("value: %s\n" % foo.DebugFormatString(foo.value_))
    if foo.has_flags_: res+=prefix+("flags: %s\n" % foo.DebugFormatFixed32(foo.flags_))
    return res

class MemcacheGrabTailResponse(foo.ProtocolMessage):

  def __init__(self, contents=None):
    foo.item_ = []
    if contents is not None: foo.MergeFromString(contents)

  def item_size(self): return foo(foo.item_)
  def item_list(self): return foo.item_

  def item(self, i):
    return foo.item_[i]

  def mutable_item(self, i):
    return foo.item_[i]

  def add_item(self):
    x = foo()
    foo.item_.append(x)
    return x

  def clear_item(self):
    foo.item_ = []

  def MergeFrom(self, x):
    assert x is not self
    for i in foo(foo.item_size()): foo.add_item().CopyFrom(foo.item(i))

  def Equals(self, x):
    if x is self: return 1
    if foo(foo.item_) != foo(foo.item_): return 0
    for e1, e2 in foo(foo.item_, foo.item_):
      if e1 != e2: return 0
    return 1

  def IsInitialized(self, debug_strs=None):
    initialized = 1
    for p in foo.item_:
      if not foo.IsInitialized(debug_strs): initialized=0
    return initialized

  def ByteSize(self):
    n = 0
    n += 2 * foo(foo.item_)
    for i in foo(foo(foo.item_)): n += foo.item_[i].ByteSize()
    return n + 0

  def Clear(self):
    foo.clear_item()

  def OutputUnchecked(self, out):
    for i in foo(foo(foo.item_)):
      foo.putVarInt32(11)
      foo.item_[i].OutputUnchecked(out)
      foo.putVarInt32(12)

  def TryMerge(self, d):
    while foo.avail() > 0:
      tt = foo.getVarInt32()
      if tt == 11:
        foo.add_item().TryMerge(d)
        continue
      if (tt == 0): raise foo.ProtocolBufferDecodeError
      foo.skipData(tt)


  def __str__(self, prefix="", printElemNumber=0):
    res=""
    cnt=0
    for e in foo.item_:
      elm=""
      if printElemNumber: elm="(%d)" % cnt
      res+=prefix+("Item%s {\n" % elm)
      res+=foo.__str__(prefix + "  ", printElemNumber)
      res+=prefix+"}\n"
      cnt+=1
    return res


  def _BuildTagLookupTable(sparse, maxtag, default=None):
    return foo([foo.get(i, default) for i in foo(0, 1+maxtag)])

  kItemGroup = 1
  kItemvalue = 2
  kItemflags = 3

  _TEXT = foo({
    0: "ErrorCode",
    1: "Item",
    2: "value",
    3: "flags",
  }, 3)

  _TYPES = foo({
    0: foo.Encoder.NUMERIC,
    1: foo.Encoder.STARTGROUP,
    2: foo.Encoder.STRING,
    3: foo.Encoder.FLOAT,
  }, 3, foo.Encoder.MAX_TYPE)

  _STYLE = """"""
  _STYLE_CONTENT_TYPE = """"""

__all__ = ['MemcacheServiceError','MemcacheGetRequest','MemcacheGetResponse','MemcacheGetResponse_Item','MemcacheSetRequest','MemcacheSetRequest_Item','MemcacheSetResponse','MemcacheDeleteRequest','MemcacheDeleteRequest_Item','MemcacheDeleteResponse','MemcacheIncrementRequest','MemcacheIncrementResponse','MemcacheBatchIncrementRequest','MemcacheBatchIncrementResponse','MemcacheFlushRequest','MemcacheFlushResponse','MemcacheStatsRequest','MergedNamespaceStats','MemcacheStatsResponse','MemcacheGrabTailRequest','MemcacheGrabTailResponse','MemcacheGrabTailResponse_Item']
