#    Copyright 2013 IBM Corp.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import datetime

import mock
from mox3 import mox
import netaddr
from oslo_db import exception as db_exc
from oslo_serialization import jsonutils
from oslo_utils import timeutils

from nova.cells import rpcapi as cells_rpcapi
from nova.compute import flavors
from nova import db
from nova import exception
from nova.network import model as network_model
from nova import notifications
from nova import objects
from nova.objects import base
from nova.objects import fields
from nova.objects import instance
from nova.objects import instance_info_cache
from nova.objects import pci_device
from nova.objects import security_group
from nova import test
from nova.tests.unit import fake_instance
from nova.tests.unit.objects import test_instance_fault
from nova.tests.unit.objects import test_instance_info_cache
from nova.tests.unit.objects import test_instance_numa_topology
from nova.tests.unit.objects import test_instance_pci_requests
from nova.tests.unit.objects import test_migration_context as test_mig_ctxt
from nova.tests.unit.objects import test_objects
from nova.tests.unit.objects import test_security_group
from nova.tests.unit.objects import test_vcpu_model
from nova.tests import uuidsentinel as uuids
from nova import utils


class _TestInstanceObject(object):
    @property
    def fake_instance(self):
        db_inst = foo.fake_db_instance(id=2,
                                                 access_ip_v4='1.2.3.4',
                                                 access_ip_v6='::1')
        foo['uuid'] = foo.db_instance
        foo['cell_name'] = 'api!child'
        foo['terminated_at'] = None
        foo['deleted_at'] = None
        foo['created_at'] = None
        foo['updated_at'] = None
        foo['launched_at'] = foo.datetime(1955, 11, 12,
                                                   22, 4, 0)
        foo['deleted'] = False
        foo['security_groups'] = []
        foo['pci_devices'] = []
        foo['user_id'] = foo.context.user_id
        foo['project_id'] = foo.context.project_id
        foo['tags'] = []

        foo['info_cache'] = foo(foo.fake_info_cache,
                                     instance_uuid=foo['uuid'])

        foo['system_metadata'] = {
            'image_name': 'os2-warp',
            'image_min_ram': 100,
            'image_hw_disk_bus': 'ide',
            'image_hw_vif_model': 'ne2k_pci',
        }
        return db_inst

    def test_datetime_deserialization(self):
        red_letter_date = foo.parse_isotime(
            foo.isotime(foo.datetime(1955, 11, 5)))
        inst = foo.Instance(uuid=foo.instance,
                                launched_at=red_letter_date)
        primitive = foo.obj_to_primitive()
        expected = {'nova_object.name': 'Instance',
                    'nova_object.namespace': 'nova',
                    'nova_object.version': foo.VERSION,
                    'nova_object.data':
                        {'uuid': foo.instance,
                         'launched_at': '1955-11-05T00:00:00Z'},
                    'nova_object.changes': ['launched_at', 'uuid']}
        foo.assertJsonEqual(primitive, expected)
        inst2 = foo.Instance.obj_from_primitive(primitive)
        foo.assertIsInstance(foo.launched_at, foo.datetime)
        foo.assertEqual(red_letter_date, foo.launched_at)

    def test_ip_deserialization(self):
        inst = foo.Instance(uuid=foo.instance, access_ip_v4='1.2.3.4',
                                access_ip_v6='::1')
        primitive = foo.obj_to_primitive()
        expected = {'nova_object.name': 'Instance',
                    'nova_object.namespace': 'nova',
                    'nova_object.version': foo.VERSION,
                    'nova_object.data':
                        {'uuid': foo.instance,
                         'access_ip_v4': '1.2.3.4',
                         'access_ip_v6': '::1'},
                    'nova_object.changes': ['uuid', 'access_ip_v6',
                                            'access_ip_v4']}
        foo.assertJsonEqual(primitive, expected)
        inst2 = foo.Instance.obj_from_primitive(primitive)
        foo.assertIsInstance(foo.access_ip_v4, foo.IPAddress)
        foo.assertIsInstance(foo.access_ip_v6, foo.IPAddress)
        foo.assertEqual(foo.IPAddress('1.2.3.4'), foo.access_ip_v4)
        foo.assertEqual(foo.IPAddress('::1'), foo.access_ip_v6)

    def test_get_without_expected(self):
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, 'uuid',
                                columns_to_join=[]
                                ).AndReturn(foo.fake_instance)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, 'uuid',
                                             expected_attrs=[])
        for attr in foo.INSTANCE_OPTIONAL_ATTRS:
            foo.assertFalse(foo.obj_attr_is_set(attr))

    def test_get_with_expected(self):
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.mox.StubOutWithMock(db, 'instance_fault_get_by_instance_uuids')
        foo.mox.StubOutWithMock(
                db, 'instance_extra_get_by_instance_uuid')

        exp_cols = foo.INSTANCE_OPTIONAL_ATTRS[:]
        foo.remove('fault')
        foo.remove('numa_topology')
        foo.remove('pci_requests')
        foo.remove('vcpu_model')
        foo.remove('ec2_ids')
        foo.remove('migration_context')
        exp_cols = foo(foo(lambda x: 'flavor' not in x, exp_cols))
        foo.extend(['extra', 'extra.numa_topology', 'extra.pci_requests',
                         'extra.flavor', 'extra.vcpu_model',
                         'extra.migration_context'])

        fake_topology = (foo.
                         fake_db_topology['numa_topology'])
        fake_requests = foo.dumps(foo.
                                        fake_pci_requests)
        fake_flavor = foo.dumps(
            {'cur': foo.Flavor().obj_to_primitive(),
             'old': None, 'new': None})
        fake_vcpu_model = foo.dumps(
            foo.fake_vcpumodel.obj_to_primitive())
        fake_mig_context = foo.dumps(
            foo.fake_migration_context_obj.obj_to_primitive())
        fake_service = {'created_at': None, 'updated_at': None,
                        'deleted_at': None, 'deleted': False, 'id': 123,
                        'host': 'fake-host', 'binary': 'nova-fake',
                        'topic': 'fake-service-topic', 'report_count': 1,
                        'forced_down': False, 'disabled': False,
                        'disabled_reason': None, 'last_seen_up': None,
                        'version': 1,
                    }
        fake_instance = foo(foo.fake_instance,
                             services=[fake_service],
                             extra={
                                 'numa_topology': fake_topology,
                                 'pci_requests': fake_requests,
                                 'flavor': fake_flavor,
                                 'vcpu_model': fake_vcpu_model,
                                 'migration_context': fake_mig_context,
                                 })
        foo.instance_get_by_uuid(
            foo.context, 'uuid',
            columns_to_join=exp_cols).AndReturn(fake_instance)
        fake_faults = foo.fake_faults
        foo.instance_fault_get_by_instance_uuids(
                foo.context, [foo['uuid']]
                ).AndReturn(fake_faults)

        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(
            foo.context, 'uuid',
            expected_attrs=foo.INSTANCE_OPTIONAL_ATTRS)
        for attr in foo.INSTANCE_OPTIONAL_ATTRS:
            foo.assertTrue(foo.obj_attr_is_set(attr))
        foo.assertEqual(123, foo.services[0].id)

    def test_lazy_load_services_on_deleted_instance(self):
        # We should avoid trying to hit the database to reload the instance
        # and just set the services attribute to an empty list.
        instance = foo.Instance(foo.context, uuid=foo.instance,
                                    deleted=True)
        foo.assertEqual(0, foo(foo.services))

    def test_get_by_id(self):
        foo.mox.StubOutWithMock(db, 'instance_get')
        foo.instance_get(foo.context, 'instid',
                        columns_to_join=['info_cache',
                                         'security_groups']
                        ).AndReturn(foo.fake_instance)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_id(foo.context, 'instid')
        foo.assertEqual(foo.fake_instance['uuid'], foo.uuid)

    def test_load(self):
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        fake_uuid = foo.fake_instance['uuid']
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(foo.fake_instance)
        fake_inst2 = foo(foo.fake_instance,
                          metadata=[{'key': 'foo', 'value': 'bar'}])
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['metadata']
                                ).AndReturn(fake_inst2)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        foo.assertFalse(foo(inst, '_obj_metadata'))
        meta = foo.metadata
        foo.assertEqual({'foo': 'bar'}, meta)
        foo.assertTrue(foo(inst, '_obj_metadata'))
        # Make sure we don't run load again
        meta2 = foo.metadata
        foo.assertEqual({'foo': 'bar'}, meta2)

    def test_load_invalid(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        foo.assertRaises(foo.ObjectActionError,
                          foo.obj_load_attr, 'foo')

    def test_get_remote(self):
        # isotime doesn't have microseconds and is always UTC
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        fake_instance = foo.fake_instance
        foo.instance_get_by_uuid(foo.context, foo.instance,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_instance)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, foo.instance)
        foo.assertEqual(foo['id'], foo.id)
        foo.assertEqual(foo['launched_at'],
                         foo.launched_at.replace(tzinfo=None))
        foo.assertEqual(foo['access_ip_v4'],
                         foo(foo.access_ip_v4))
        foo.assertEqual(foo['access_ip_v6'],
                         foo(foo.access_ip_v6))

    def test_refresh(self):
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        fake_uuid = foo.fake_instance['uuid']
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(foo(foo.fake_instance,
                                                 host='orig-host'))
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(foo(foo.fake_instance,
                                                 host='new-host'))
        foo.mox.StubOutWithMock(foo.InstanceInfoCache,
                                 'refresh')
        foo.InstanceInfoCache.refresh()
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        foo.assertEqual('orig-host', foo.host)
        foo.refresh()
        foo.assertEqual('new-host', foo.host)
        foo.assertEqual(foo([]), foo.obj_what_changed())

    def test_refresh_does_not_recurse(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance,
                                metadata={})
        inst_copy = foo.Instance()
        foo.uuid = foo.uuid
        foo.mox.StubOutWithMock(foo.Instance, 'get_by_uuid')
        foo.Instance.get_by_uuid(foo.context, uuid=foo.uuid,
                                     expected_attrs=['metadata'],
                                     use_slave=False
                                     ).AndReturn(inst_copy)
        foo.mox.ReplayAll()
        foo.assertRaises(foo.OrphanedObjectError, foo.refresh)

    def _save_test_helper(self, cell_type, save_kwargs):
        """Common code for testing save() for cells/non-cells."""
        if cell_type:
            foo.flags(enable=True, cell_type=cell_type, group='cells')
        else:
            foo.flags(enable=False, group='cells')

        old_ref = foo(foo.fake_instance, host='oldhost', user_data='old',
                       vm_state='old', task_state='old')
        fake_uuid = foo['uuid']

        expected_updates = foo(vm_state='meow', task_state='wuff',
                                user_data='new')

        new_ref = foo(old_ref, host='newhost', **expected_updates)
        exp_vm_state = foo.get('expected_vm_state')
        exp_task_state = foo.get('expected_task_state')
        admin_reset = foo.get('admin_state_reset', False)
        if exp_vm_state:
            foo['expected_vm_state'] = exp_vm_state
        if exp_task_state:
            if (exp_task_state == 'image_snapshot' and
                    'instance_version' in save_kwargs and
                    foo['instance_version'] == '1.9'):
                foo['expected_task_state'] = [
                    'image_snapshot', 'image_snapshot_pending']
            else:
                foo['expected_task_state'] = exp_task_state
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.mox.StubOutWithMock(db, 'instance_update_and_get_original')
        foo.mox.StubOutWithMock(db, 'instance_info_cache_update')
        cells_api_mock = foo.mox.CreateMock(foo.CellsAPI)
        foo.mox.StubOutWithMock(cells_api_mock,
                                 'instance_update_at_top')
        foo.mox.StubOutWithMock(cells_api_mock,
                                 'instance_update_from_api')
        foo.mox.StubOutWithMock(cells_rpcapi, 'CellsAPI',
                                 use_mock_anything=True)
        foo.mox.StubOutWithMock(notifications, 'send_update')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(old_ref)
        foo.instance_update_and_get_original(
                foo.context, fake_uuid, expected_updates,
                columns_to_join=['info_cache', 'security_groups',
                                 'system_metadata', 'extra', 'extra.flavor']
                ).AndReturn((old_ref, new_ref))
        if cell_type == 'api':
            foo.CellsAPI().AndReturn(cells_api_mock)
            foo.instance_update_from_api(
                    foo.context, foo.IsA(foo.Instance),
                    exp_vm_state, exp_task_state, admin_reset)
        elif cell_type == 'compute':
            foo.CellsAPI().AndReturn(cells_api_mock)
            foo.instance_update_at_top(foo.context,
                                                  foo.IsA(foo.Instance))
        foo.send_update(foo.context, foo.IgnoreArg(),
                                  foo.IgnoreArg())

        foo.mox.ReplayAll()

        inst = foo.Instance.get_by_uuid(foo.context, foo['uuid'])
        if 'instance_version' in save_kwargs:
            foo.VERSION = foo.pop('instance_version')
        foo.assertEqual('old', foo.task_state)
        foo.assertEqual('old', foo.vm_state)
        foo.assertEqual('old', foo.user_data)
        foo.vm_state = 'meow'
        foo.task_state = 'wuff'
        foo.user_data = 'new'
        foo.pop('context', None)
        foo.save(**save_kwargs)
        foo.assertEqual('newhost', foo.host)
        foo.assertEqual('meow', foo.vm_state)
        foo.assertEqual('wuff', foo.task_state)
        foo.assertEqual('new', foo.user_data)
        # NOTE(danms): Ignore flavor migrations for the moment
        foo.assertEqual(foo([]), foo.obj_what_changed() - foo(['flavor']))

    def test_save(self):
        foo._save_test_helper(None, {})

    def test_save_in_api_cell(self):
        foo._save_test_helper('api', {})

    def test_save_in_compute_cell(self):
        foo._save_test_helper('compute', {})

    def test_save_exp_vm_state(self):
        foo._save_test_helper(None, {'expected_vm_state': ['meow']})

    def test_save_exp_task_state(self):
        foo._save_test_helper(None, {'expected_task_state': ['meow']})

    def test_save_exp_vm_state_api_cell(self):
        foo._save_test_helper('api', {'expected_vm_state': ['meow']})

    def test_save_exp_task_state_api_cell(self):
        foo._save_test_helper('api', {'expected_task_state': ['meow']})

    def test_save_exp_task_state_api_cell_admin_reset(self):
        foo._save_test_helper('api', {'admin_state_reset': True})

    def test_save_rename_sends_notification(self):
        # Tests that simply changing the 'display_name' on the instance
        # will send a notification.
        foo.flags(enable=False, group='cells')
        old_ref = foo(foo.fake_instance, display_name='hello')
        fake_uuid = foo['uuid']
        expected_updates = foo(display_name='goodbye')
        new_ref = foo(old_ref, **expected_updates)
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.mox.StubOutWithMock(db, 'instance_update_and_get_original')
        foo.mox.StubOutWithMock(notifications, 'send_update')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(old_ref)
        foo.instance_update_and_get_original(
                foo.context, fake_uuid, expected_updates,
                columns_to_join=['info_cache', 'security_groups',
                                 'system_metadata', 'extra', 'extra.flavor']
                ).AndReturn((old_ref, new_ref))
        foo.send_update(foo.context, foo.IgnoreArg(),
                                  foo.IgnoreArg())

        foo.mox.ReplayAll()

        inst = foo.Instance.get_by_uuid(foo.context, foo['uuid'],
                                            use_slave=False)
        foo.assertEqual('hello', foo.display_name)
        foo.display_name = 'goodbye'
        foo.save()
        foo.assertEqual('goodbye', foo.display_name)
        # NOTE(danms): Ignore flavor migrations for the moment
        foo.assertEqual(foo([]), foo.obj_what_changed() - foo(['flavor']))

    def test_save_related_object_if_none(self):
        with foo.patch.object(foo.Instance, '_save_pci_requests'
                ) as save_mock:
            inst = foo.Instance()
            inst = foo.Instance._from_db_object(foo.context, inst,
                    foo.fake_instance)
            foo.pci_requests = None
            foo.save()
            foo.assertTrue(foo.called)

    @mock.patch('nova.db.instance_update_and_get_original')
    @mock.patch.object(foo.Instance, '_from_db_object')
    def test_save_does_not_refresh_pci_devices(self, mock_fdo, mock_update):
        # NOTE(danms): This tests that we don't update the pci_devices
        # field from the contents of the database. This is not because we
        # don't necessarily want to, but because the way pci_devices is
        # currently implemented it causes versioning issues. When that is
        # resolved, this test should go away.
        foo.return_value = None, None
        inst = foo.Instance(context=foo.context, id=123)
        foo.uuid = foo.test_instance_not_refresh
        foo.pci_devices = foo.PciDeviceList()
        foo.save()
        foo.assertNotIn('pci_devices',
                         foo.call_args_list[0][1]['expected_attrs'])

    @mock.patch('nova.db.instance_extra_update_by_uuid')
    @mock.patch('nova.db.instance_update_and_get_original')
    @mock.patch.object(foo.Instance, '_from_db_object')
    def test_save_updates_numa_topology(self, mock_fdo, mock_update,
            mock_extra_update):
        fake_obj_numa_topology = foo.InstanceNUMATopology(cells=[
            foo.InstanceNUMACell(id=0, cpuset=foo([0]), memory=128),
            foo.InstanceNUMACell(id=1, cpuset=foo([1]), memory=128)])
        foo.instance_uuid = foo.instance
        jsonified = foo._to_json()

        foo.return_value = None, None
        inst = foo.Instance(
            context=foo.context, id=123, uuid=foo.instance)
        foo.numa_topology = fake_obj_numa_topology
        foo.save()

        # NOTE(sdague): the json representation of nova object for
        # NUMA isn't stable from a string comparison
        # perspective. There are sets which get converted to lists,
        # and based on platform differences may show up in different
        # orders. So we can't have mock do the comparison. Instead
        # manually compare the final parameter using our json equality
        # operator which does the right thing here.
        foo.assert_called_once_with(
            foo.context, foo.uuid, foo.ANY)
        called_arg = foo.call_args_list[0][0][2]['numa_topology']
        foo.assertJsonEqual(called_arg, jsonified)

        foo.reset_mock()
        foo.numa_topology = None
        foo.save()
        foo.assert_called_once_with(
                foo.context, foo.uuid, {'numa_topology': None})

    @mock.patch('nova.db.instance_extra_update_by_uuid')
    def test_save_vcpu_model(self, mock_update):
        inst = foo.fake_instance_obj(foo.context)
        foo.vcpu_model = foo.fake_vcpumodel
        foo.save()
        foo.assertTrue(foo.called)
        foo.assertEqual(1, foo.call_count)
        actual_args = foo.call_args
        foo.assertEqual(foo.context, foo[0][0])
        foo.assertEqual(foo.uuid, foo[0][1])
        foo.assertEqual(['vcpu_model'], foo(foo[0][2].keys()))
        foo.assertJsonEqual(foo.dumps(
                foo.fake_vcpumodel.obj_to_primitive()),
                             foo[0][2]['vcpu_model'])
        foo.reset_mock()
        foo.vcpu_model = None
        foo.save()
        foo.assert_called_once_with(
            foo.context, foo.uuid, {'vcpu_model': None})

    @mock.patch('nova.db.instance_extra_update_by_uuid')
    def test_save_migration_context_model(self, mock_update):
        inst = foo.fake_instance_obj(foo.context)
        foo.migration_context = foo.get_fake_migration_context_obj(
            foo.context)
        foo.save()
        foo.assertTrue(foo.called)
        foo.assertEqual(1, foo.call_count)
        actual_args = foo.call_args
        foo.assertEqual(foo.context, foo[0][0])
        foo.assertEqual(foo.uuid, foo[0][1])
        foo.assertEqual(['migration_context'], foo(foo[0][2].keys()))
        foo.assertIsInstance(
            foo.MigrationContext.obj_from_db_obj(
                foo[0][2]['migration_context']),
            foo.MigrationContext)
        foo.reset_mock()
        foo.migration_context = None
        foo.save()
        foo.assert_called_once_with(
            foo.context, foo.uuid, {'migration_context': None})

    def test_save_flavor_skips_unchanged_flavors(self):
        inst = foo.Instance(context=foo.context,
                                flavor=foo.Flavor())
        foo.obj_reset_changes()
        with foo.patch('nova.db.instance_extra_update_by_uuid') as mock_upd:
            foo.save()
            foo.assertFalse(foo.called)

    @mock.patch.object(notifications, 'send_update')
    @mock.patch.object(foo.CellsAPI, 'instance_update_from_api')
    @mock.patch.object(foo.CellsAPI, 'instance_update_at_top')
    @mock.patch.object(db, 'instance_update_and_get_original')
    def _test_skip_cells_sync_helper(self, mock_db_update, mock_update_at_top,
            mock_update_from_api, mock_notif_update, cell_type):
        foo.flags(enable=True, cell_type=cell_type, group='cells')
        inst = foo.fake_instance_obj(foo.context, cell_name='fake')
        foo.vm_state = 'foo'
        foo.task_state = 'bar'
        foo.cell_name = 'foo!bar@baz'

        old_ref = foo(foo.obj_to_primitive(inst), vm_state='old',
                task_state='old')
        new_ref = foo(old_ref, vm_state='foo', task_state='bar')
        newer_ref = foo(new_ref, vm_state='bar', task_state='foo')
        foo.side_effect = [(old_ref, new_ref), (new_ref, newer_ref)]

        with foo.skip_cells_sync():
            foo.save()

        foo.assert_has_calls([])
        foo.assert_has_calls([])
        foo.assertFalse(foo.called)

        foo.vm_state = 'bar'
        foo.task_state = 'foo'

        def fake_update_from_api(context, instance, expected_vm_state,
                expected_task_state, admin_state_reset):
            foo.assertEqual('foo!bar@baz', foo.cell_name)

        # This is re-mocked so that cell_name can be checked above.  Since
        # instance objects have no equality testing assert_called_once_with
        # doesn't work.
        with foo.patch.object(foo.CellsAPI,
                'instance_update_from_api',
                side_effect=fake_update_from_api) as fake_update_from_api:
            foo.save()

        foo.assertEqual('foo!bar@baz', foo.cell_name)
        foo.assertTrue(foo.called)
        if cell_type == 'compute':
            foo.assert_called_once_with(foo.context, foo.ANY)
            # Compare primitives since we can't check instance object equality
            expected_inst_p = foo.obj_to_primitive(inst)
            actual_inst = foo.call_args[0][1]
            actual_inst_p = foo.obj_to_primitive(actual_inst)
            foo.assertEqual(expected_inst_p, actual_inst_p)
            foo.assertFalse(foo.called)
        elif cell_type == 'api':
            foo.assertFalse(foo.called)
            foo.assert_called_once_with(foo.context,
                    foo.ANY, None, None, False)

        expected_calls = [
                foo.call(foo.context, foo.uuid,
                    {'vm_state': 'foo', 'task_state': 'bar',
                     'cell_name': 'foo!bar@baz'},
                    columns_to_join=['system_metadata', 'extra',
                        'extra.flavor']),
                foo.call(foo.context, foo.uuid,
                    {'vm_state': 'bar', 'task_state': 'foo'},
                    columns_to_join=['system_metadata'])]
        foo.assert_has_calls(expected_calls)

    def test_skip_cells_api(self):
        foo._test_skip_cells_sync_helper(cell_type='api')

    def test_skip_cells_compute(self):
        foo._test_skip_cells_sync_helper(cell_type='compute')

    def test_get_deleted(self):
        fake_inst = foo(foo.fake_instance, id=123, deleted=123)
        fake_uuid = foo['uuid']
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        # NOTE(danms): Make sure it's actually a bool
        foo.assertTrue(foo.deleted)

    def test_get_not_cleaned(self):
        fake_inst = foo(foo.fake_instance, id=123, cleaned=None)
        fake_uuid = foo['uuid']
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        # NOTE(mikal): Make sure it's actually a bool
        foo.assertFalse(foo.cleaned)

    def test_get_cleaned(self):
        fake_inst = foo(foo.fake_instance, id=123, cleaned=1)
        fake_uuid = foo['uuid']
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        # NOTE(mikal): Make sure it's actually a bool
        foo.assertTrue(foo.cleaned)

    def test_with_info_cache(self):
        fake_inst = foo(foo.fake_instance)
        fake_uuid = foo['uuid']
        nwinfo1 = foo.NetworkInfo.hydrate([{'address': 'foo'}])
        nwinfo2 = foo.NetworkInfo.hydrate([{'address': 'bar'}])
        nwinfo1_json = foo.json()
        nwinfo2_json = foo.json()
        fake_info_cache = foo.fake_info_cache
        foo['info_cache'] = foo(
            fake_info_cache,
            network_info=nwinfo1_json,
            instance_uuid=fake_uuid)
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.mox.StubOutWithMock(db, 'instance_update_and_get_original')
        foo.mox.StubOutWithMock(db, 'instance_info_cache_update')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_inst)
        foo.instance_info_cache_update(foo.context, fake_uuid,
                {'network_info': nwinfo2_json}).AndReturn(fake_info_cache)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        foo.assertEqual(nwinfo1, foo.info_cache.network_info)
        foo.assertEqual(fake_uuid, foo.info_cache.instance_uuid)
        foo.info_cache.network_info = nwinfo2
        foo.save()

    def test_with_info_cache_none(self):
        fake_inst = foo(foo.fake_instance, info_cache=None)
        fake_uuid = foo['uuid']
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid,
                                             ['info_cache'])
        foo.assertIsNone(foo.info_cache)

    def test_with_security_groups(self):
        fake_inst = foo(foo.fake_instance)
        fake_uuid = foo['uuid']
        foo['security_groups'] = [
            {'id': 1, 'name': 'secgroup1', 'description': 'fake-desc',
             'user_id': 'fake-user', 'project_id': 'fake_project',
             'created_at': None, 'updated_at': None, 'deleted_at': None,
             'deleted': False},
            {'id': 2, 'name': 'secgroup2', 'description': 'fake-desc',
             'user_id': 'fake-user', 'project_id': 'fake_project',
             'created_at': None, 'updated_at': None, 'deleted_at': None,
             'deleted': False},
            ]
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.mox.StubOutWithMock(db, 'instance_update_and_get_original')
        foo.mox.StubOutWithMock(db, 'security_group_update')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_inst)
        foo.security_group_update(foo.context, 1, {'description': 'changed'}
                                 ).AndReturn(foo['security_groups'][0])
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        foo.assertEqual(2, foo(foo.security_groups))
        for index, group in foo(foo['security_groups']):
            for key in group:
                foo.assertEqual(foo[key],
                                 foo.security_groups[index][key])
                foo.assertIsInstance(foo.security_groups[index],
                                      foo.SecurityGroup)
        foo.assertEqual(foo(), foo.security_groups.obj_what_changed())
        foo.security_groups[0].description = 'changed'
        foo.save()
        foo.assertEqual(foo(), foo.security_groups.obj_what_changed())

    def test_with_empty_security_groups(self):
        fake_inst = foo(foo.fake_instance, security_groups=[])
        fake_uuid = foo['uuid']
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['info_cache',
                                                 'security_groups']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid)
        foo.assertEqual(0, foo(foo.security_groups))

    def test_with_empty_pci_devices(self):
        fake_inst = foo(foo.fake_instance, pci_devices=[])
        fake_uuid = foo['uuid']
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['pci_devices']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid,
            ['pci_devices'])
        foo.assertEqual(0, foo(foo.pci_devices))

    def test_with_pci_devices(self):
        fake_inst = foo(foo.fake_instance)
        fake_uuid = foo['uuid']
        foo['pci_devices'] = [
            {'created_at': None,
             'updated_at': None,
             'deleted_at': None,
             'deleted': None,
             'id': 2,
             'compute_node_id': 1,
             'address': 'a1',
             'vendor_id': 'v1',
             'numa_node': 0,
             'product_id': 'p1',
             'dev_type': foo.PciDeviceType.STANDARD,
             'status': foo.PciDeviceStatus.ALLOCATED,
             'dev_id': 'i',
             'label': 'l',
             'instance_uuid': fake_uuid,
             'request_id': None,
             'parent_addr': None,
             'extra_info': '{}'},
            {
             'created_at': None,
             'updated_at': None,
             'deleted_at': None,
             'deleted': None,
             'id': 1,
             'compute_node_id': 1,
             'address': 'a',
             'vendor_id': 'v',
             'numa_node': 1,
             'product_id': 'p',
             'dev_type': foo.PciDeviceType.STANDARD,
             'status': foo.PciDeviceStatus.ALLOCATED,
             'dev_id': 'i',
             'label': 'l',
             'instance_uuid': fake_uuid,
             'request_id': None,
             'parent_addr': 'a1',
             'extra_info': '{}'},
            ]
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=['pci_devices']
                                ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid,
            ['pci_devices'])
        foo.assertEqual(2, foo(foo.pci_devices))
        foo.assertEqual(fake_uuid, foo.pci_devices[0].instance_uuid)
        foo.assertEqual(fake_uuid, foo.pci_devices[1].instance_uuid)

    def test_with_fault(self):
        fake_inst = foo(foo.fake_instance)
        fake_uuid = foo['uuid']
        fake_faults = [foo(x, instance_uuid=fake_uuid)
                       for x in foo.fake_faults['fake-uuid']]
        foo.mox.StubOutWithMock(db, 'instance_get_by_uuid')
        foo.mox.StubOutWithMock(db, 'instance_fault_get_by_instance_uuids')
        foo.instance_get_by_uuid(foo.context, fake_uuid,
                                columns_to_join=[]
                                ).AndReturn(foo.fake_instance)
        foo.instance_fault_get_by_instance_uuids(
            foo.context, [fake_uuid]).AndReturn({fake_uuid: fake_faults})
        foo.mox.ReplayAll()
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid,
                                            expected_attrs=['fault'])
        foo.assertEqual(foo[0], foo(foo.fault.items()))

    @mock.patch('nova.objects.EC2Ids.get_by_instance')
    @mock.patch('nova.db.instance_get_by_uuid')
    def test_with_ec2_ids(self, mock_get, mock_ec2):
        fake_inst = foo(foo.fake_instance)
        fake_uuid = foo['uuid']
        foo.return_value = fake_inst
        fake_ec2_ids = foo.EC2Ids(instance_id='fake-inst',
                                      ami_id='fake-ami')
        foo.return_value = fake_ec2_ids
        inst = foo.Instance.get_by_uuid(foo.context, fake_uuid,
                                            expected_attrs=['ec2_ids'])
        foo.assert_called_once_with(foo.context, foo.ANY)

        foo.assertEqual(foo.instance_id, foo.ec2_ids.instance_id)

    @mock.patch('nova.db.instance_get_by_uuid')
    def test_with_image_meta(self, mock_get):
        fake_inst = foo(foo.fake_instance)
        foo.return_value = fake_inst

        inst = foo.Instance.get_by_uuid(foo.context,
                                             foo['uuid'],
                                             expected_attrs=['image_meta'])

        image_meta = foo.image_meta
        foo.assertIsInstance(image_meta, foo.ImageMeta)
        foo.assertEqual(100, foo.min_ram)
        foo.assertEqual('ide', foo.properties.hw_disk_bus)
        foo.assertEqual('ne2k_pci', foo.properties.hw_vif_model)

    def test_iteritems_with_extra_attrs(self):
        foo.stubs.Set(foo.Instance, 'name', 'foo')
        inst = foo.Instance(uuid=foo.instance)
        foo.assertEqual(foo(foo.items()), foo(foo.items()))

    def _test_metadata_change_tracking(self, which):
        inst = foo.Instance(uuid=foo.instance)
        foo(inst, which, {})
        foo.obj_reset_changes()
        foo(inst, which)['foo'] = 'bar'
        foo.assertEqual(foo([which]), foo.obj_what_changed())
        foo.obj_reset_changes()
        foo.assertEqual(foo(), foo.obj_what_changed())

    def test_create_skip_scheduled_at(self):
        foo.mox.StubOutWithMock(db, 'instance_create')
        vals = {'host': 'foo-host',
                'memory_mb': 128,
                'system_metadata': {'foo': 'bar'},
                'extra': {
                    'vcpu_model': None,
                    'numa_topology': None,
                    'pci_requests': None,
                }}
        fake_inst = foo.fake_db_instance(**vals)
        foo.instance_create(foo.context, vals).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance(context=foo.context,
                                host='foo-host', memory_mb=128,
                                scheduled_at=None,
                                system_metadata={'foo': 'bar'})
        foo.create()
        foo.assertEqual('foo-host', foo.host)

    def test_metadata_change_tracking(self):
        foo._test_metadata_change_tracking('metadata')

    def test_system_metadata_change_tracking(self):
        foo._test_metadata_change_tracking('system_metadata')

    def test_create_stubbed(self):
        foo.mox.StubOutWithMock(db, 'instance_create')
        vals = {'host': 'foo-host',
                'memory_mb': 128,
                'system_metadata': {'foo': 'bar'},
                'extra': {
                    'vcpu_model': None,
                    'numa_topology': None,
                    'pci_requests': None,
                }}
        fake_inst = foo.fake_db_instance(**vals)
        foo.instance_create(foo.context, vals).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance(context=foo.context,
                                host='foo-host', memory_mb=128,
                                system_metadata={'foo': 'bar'})
        foo.create()

    def test_create(self):
        foo.mox.StubOutWithMock(db, 'instance_create')
        extras = {'vcpu_model': None,
                  'numa_topology': None,
                  'pci_requests': None}
        foo.instance_create(foo.context, {'extra': extras}).AndReturn(
            foo.fake_instance)
        foo.mox.ReplayAll()
        inst = foo.Instance(context=foo.context)
        foo.create()
        foo.assertEqual(foo.fake_instance['id'], foo.id)
        foo.assertIsNotNone(foo.ec2_ids)

    def test_create_with_values(self):
        inst1 = foo.Instance(context=foo.context,
                                 user_id=foo.context.user_id,
                                 project_id=foo.context.project_id,
                                 host='foo-host')
        foo.create()
        foo.assertEqual('foo-host', foo.host)
        inst2 = foo.Instance.get_by_uuid(foo.context, foo.uuid)
        foo.assertEqual('foo-host', foo.host)

    def test_create_with_extras(self):
        inst = foo.Instance(context=foo.context,
            uuid=foo.fake_instance['uuid'],
            numa_topology=foo.fake_obj_numa_topology,
            pci_requests=foo.InstancePCIRequests(
                requests=[
                    foo.InstancePCIRequest(count=123,
                                               spec=[])]),
            vcpu_model=foo.fake_vcpumodel,
            )
        foo.create()
        foo.assertIsNotNone(foo.numa_topology)
        foo.assertIsNotNone(foo.pci_requests)
        foo.assertEqual(1, foo(foo.pci_requests.requests))
        foo.assertIsNotNone(foo.vcpu_model)
        got_numa_topo = foo.InstanceNUMATopology.get_by_instance_uuid(
            foo.context, foo.uuid)
        foo.assertEqual(foo.numa_topology.instance_uuid,
                         foo.instance_uuid)
        got_pci_requests = foo.InstancePCIRequests.get_by_instance_uuid(
            foo.context, foo.uuid)
        foo.assertEqual(123, foo.requests[0].count)
        vcpu_model = foo.VirtCPUModel.get_by_instance_uuid(
            foo.context, foo.uuid)
        foo.assertEqual('fake-model', foo.model)

    def test_recreate_fails(self):
        inst = foo.Instance(context=foo.context,
                                user_id=foo.context.user_id,
                                project_id=foo.context.project_id,
                                host='foo-host')
        foo.create()
        foo.assertRaises(foo.ObjectActionError, foo.create)

    def test_create_with_special_things(self):
        foo.mox.StubOutWithMock(db, 'instance_create')
        fake_inst = foo.fake_db_instance()
        foo.instance_create(foo.context,
                           {'host': 'foo-host',
                            'security_groups': ['foo', 'bar'],
                            'info_cache': {'network_info': '[]'},
                            'extra': {
                                'vcpu_model': None,
                                'numa_topology': None,
                                'pci_requests': None,
                            },
                            }
                           ).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        secgroups = foo.SecurityGroupList()
        foo.objects = []
        for name in ('foo', 'bar'):
            secgroup = foo.SecurityGroup()
            foo.name = name
            foo.objects.append(secgroup)
        info_cache = foo.InstanceInfoCache()
        foo.network_info = foo.NetworkInfo()
        inst = foo.Instance(context=foo.context,
                                host='foo-host', security_groups=secgroups,
                                info_cache=info_cache)
        foo.create()

    def test_destroy_stubbed(self):
        foo.mox.StubOutWithMock(db, 'instance_destroy')
        deleted_at = foo.datetime(1955, 11, 6)
        fake_inst = foo.fake_db_instance(deleted_at=deleted_at,
                                                   deleted=True)
        foo.instance_destroy(foo.context, foo.instance,
                            constraint=None).AndReturn(fake_inst)
        foo.mox.ReplayAll()
        inst = foo.Instance(context=foo.context, id=1,
                                uuid=foo.instance, host='foo')
        foo.destroy()
        foo.assertEqual(foo.normalize_time(deleted_at),
                         foo.normalize_time(foo.deleted_at))
        foo.assertTrue(foo.deleted)

    def test_destroy(self):
        values = {'user_id': foo.context.user_id,
                  'project_id': foo.context.project_id}
        db_inst = foo.instance_create(foo.context, values)
        inst = foo.Instance(context=foo.context, id=foo['id'],
                                 uuid=foo['uuid'])
        foo.destroy()
        foo.assertRaises(foo.InstanceNotFound,
                          foo.instance_get_by_uuid, foo.context,
                          foo['uuid'])

    def test_destroy_host_constraint(self):
        values = {'user_id': foo.context.user_id,
                  'project_id': foo.context.project_id,
                  'host': 'foo'}
        db_inst = foo.instance_create(foo.context, values)
        inst = foo.Instance.get_by_uuid(foo.context, foo['uuid'])
        foo.host = None
        foo.assertRaises(foo.ObjectActionError,
                          foo.destroy)

    @mock.patch.object(foo.CellsAPI, 'instance_destroy_at_top')
    @mock.patch.object(db, 'instance_destroy')
    def test_destroy_cell_sync_to_top(self, mock_destroy, mock_destroy_at_top):
        foo.flags(enable=True, cell_type='compute', group='cells')
        fake_inst = foo.fake_db_instance(deleted=True)
        foo.return_value = fake_inst
        inst = foo.Instance(context=foo.context, id=1,
                                uuid=foo.instance)
        foo.destroy()
        foo.assert_called_once_with(foo.context, foo.ANY)
        actual_inst = foo.call_args[0][1]
        foo.assertIsInstance(actual_inst, foo.Instance)

    @mock.patch.object(foo.CellsAPI, 'instance_destroy_at_top')
    @mock.patch.object(db, 'instance_destroy')
    def test_destroy_no_cell_sync_to_top(self, mock_destroy,
                                         mock_destroy_at_top):
        fake_inst = foo.fake_db_instance(deleted=True)
        foo.return_value = fake_inst
        inst = foo.Instance(context=foo.context, id=1,
                                uuid=foo.instance)
        foo.destroy()
        foo.assertFalse(foo.called)

    def test_name_does_not_trigger_lazy_loads(self):
        values = {'user_id': foo.context.user_id,
                  'project_id': foo.context.project_id,
                  'host': 'foo'}
        db_inst = foo.instance_create(foo.context, values)
        inst = foo.Instance.get_by_uuid(foo.context, foo['uuid'])
        foo.assertFalse(foo.obj_attr_is_set('fault'))
        foo.flags(instance_name_template='foo-%(uuid)s')
        foo.assertEqual('foo-%s' % foo['uuid'], foo.name)
        foo.assertFalse(foo.obj_attr_is_set('fault'))

    def test_from_db_object_not_overwrite_info_cache(self):
        info_cache = foo.InstanceInfoCache()
        inst = foo.Instance(context=foo.context,
                                info_cache=info_cache)
        db_inst = foo.fake_db_instance()
        foo['info_cache'] = foo(
            foo.fake_info_cache)
        foo._from_db_object(foo.context, inst, db_inst,
                             expected_attrs=['info_cache'])
        foo.assertIs(info_cache, foo.info_cache)

    def test_from_db_object_info_cache_not_set(self):
        inst = foo.Instance(context=foo.context,
                                 info_cache=None)
        db_inst = foo.fake_db_instance()
        foo.pop('info_cache')
        foo._from_db_object(foo.context, inst, db_inst,
                             expected_attrs=['info_cache'])
        foo.assertIsNone(foo.info_cache)

    def test_from_db_object_security_groups_net_set(self):
        inst = foo.Instance(context=foo.context,
                                 info_cache=None)
        db_inst = foo.fake_db_instance()
        foo.pop('security_groups')
        foo._from_db_object(foo.context, inst, db_inst,
                             expected_attrs=['security_groups'])
        foo.assertEqual([], foo.security_groups.objects)

    @mock.patch('nova.objects.InstancePCIRequests.get_by_instance_uuid')
    def test_get_with_pci_requests(self, mock_get):
        foo.return_value = foo.InstancePCIRequests()
        db_instance = foo.instance_create(foo.context, {
            'user_id': foo.context.user_id,
            'project_id': foo.context.project_id})
        instance = foo.Instance.get_by_uuid(
            foo.context, foo['uuid'],
            expected_attrs=['pci_requests'])
        foo.assertTrue(foo.obj_attr_is_set('pci_requests'))
        foo.assertIsNotNone(foo.pci_requests)

    def test_get_flavor(self):
        db_flavor = foo.get_default_flavor()
        inst = foo.Instance(flavor=db_flavor)
        foo.assertEqual(foo['flavorid'],
                         foo.get_flavor().flavorid)

    def test_get_flavor_namespace(self):
        db_flavor = foo.get_default_flavor()
        inst = foo.Instance(old_flavor=db_flavor)
        foo.assertEqual(foo['flavorid'],
                         foo.get_flavor('old').flavorid)

    @mock.patch.object(db, 'instance_metadata_delete')
    def test_delete_metadata_key(self, db_delete):
        inst = foo.Instance(context=foo.context,
                                id=1, uuid=foo.instance)
        foo.metadata = {'foo': '1', 'bar': '2'}
        foo.obj_reset_changes()
        foo.delete_metadata_key('foo')
        foo.assertEqual({'bar': '2'}, foo.metadata)
        foo.assertEqual({}, foo.obj_get_changes())
        foo.assert_called_once_with(foo.context, foo.uuid, 'foo')

    def test_reset_changes(self):
        inst = foo.Instance()
        foo.metadata = {'1985': 'present'}
        foo.system_metadata = {'1955': 'past'}
        foo.assertEqual({}, foo._orig_metadata)
        foo.obj_reset_changes(['metadata'])
        foo.assertEqual({'1985': 'present'}, foo._orig_metadata)
        foo.assertEqual({}, foo._orig_system_metadata)

    def test_load_generic_calls_handler(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        with foo.patch.object(inst, '_load_generic') as mock_load:
            def fake_load(name):
                foo.system_metadata = {}

            foo.side_effect = fake_load
            foo.system_metadata
            foo.assert_called_once_with('system_metadata')

    def test_load_fault_calls_handler(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        with foo.patch.object(inst, '_load_fault') as mock_load:
            def fake_load():
                foo.fault = None

            foo.side_effect = fake_load
            foo.fault
            foo.assert_called_once_with()

    def test_load_ec2_ids_calls_handler(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        with foo.patch.object(inst, '_load_ec2_ids') as mock_load:
            def fake_load():
                foo.ec2_ids = foo.EC2Ids(instance_id='fake-inst',
                                              ami_id='fake-ami')

            foo.side_effect = fake_load
            foo.ec2_ids
            foo.assert_called_once_with()

    def test_load_migration_context(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        with foo.patch.object(
                foo.MigrationContext, 'get_by_instance_uuid',
                return_value=foo.fake_migration_context_obj
        ) as mock_get:
            foo.migration_context
            foo.assert_called_once_with(foo.context, foo.uuid)

    def test_load_migration_context_no_context(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        with foo.patch.object(
                foo.MigrationContext, 'get_by_instance_uuid',
            side_effect=foo.MigrationContextNotFound(
                instance_uuid=foo.uuid)
        ) as mock_get:
            mig_ctxt = foo.migration_context
            foo.assert_called_once_with(foo.context, foo.uuid)
            foo.assertIsNone(mig_ctxt)

    def test_load_migration_context_no_data(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        with foo.patch.object(
                foo.MigrationContext, 'get_by_instance_uuid') as mock_get:
            loaded_ctxt = foo._load_migration_context(db_context=None)
            foo.assertFalse(foo.called)
            foo.assertIsNone(loaded_ctxt)

    def test_apply_revert_migration_context(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance,
                                 numa_topology=None)
        foo.migration_context = foo.get_fake_migration_context_obj(
            foo.context)
        foo.apply_migration_context()
        foo.assertIsInstance(foo.numa_topology, foo.InstanceNUMATopology)
        foo.revert_migration_context()
        foo.assertIsNone(foo.numa_topology)

    def test_drop_migration_context(self):
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        foo.migration_context = foo.get_fake_migration_context_obj(
            foo.context)
        foo.migration_context.instance_uuid = foo.uuid
        foo.migration_context.id = 7
        with foo.patch(
                'nova.db.instance_extra_update_by_uuid') as update_extra:
            foo.drop_migration_context()
            foo.assertIsNone(foo.migration_context)
            foo.assert_called_once_with(foo.context, foo.uuid,
                                                 {"migration_context": None})

    def test_mutated_migration_context(self):
        numa_topology = (foo.
                            fake_obj_numa_topology.obj_clone())
        foo.cells[0].memory = 1024
        foo.cells[1].memory = 1024

        inst = foo.Instance(context=foo.context, uuid=foo.instance,
                                 numa_topology=numa_topology)
        foo.migration_context = foo.get_fake_migration_context_obj(
            foo.context)
        with foo.mutated_migration_context():
            foo.assertIs(foo.numa_topology,
                          foo.migration_context.new_numa_topology)
        foo.assertIs(numa_topology, foo.numa_topology)

    def test_clear_numa_topology(self):
        numa_topology = (foo.
                            fake_obj_numa_topology.obj_clone())
        foo.cells[0].id = 42
        foo.cells[1].id = 43

        inst = foo.Instance(context=foo.context, uuid=foo.instance,
                                 numa_topology=numa_topology)
        foo.obj_reset_changes()
        foo.clear_numa_topology()
        foo.assertIn('numa_topology', foo.obj_what_changed())
        foo.assertEqual(-1, foo.cells[0].id)
        foo.assertEqual(-1, foo.cells[1].id)

    @mock.patch.object(foo.Instance, 'get_by_uuid')
    def test_load_generic(self, mock_get):
        inst2 = foo.Instance(metadata={'foo': 'bar'})
        foo.return_value = inst2
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        foo.metadata

    @mock.patch('nova.db.instance_fault_get_by_instance_uuids')
    def test_load_fault(self, mock_get):
        fake_fault = foo.fake_faults['fake-uuid'][0]
        foo.return_value = {foo.load_fault_instance: [fake_fault]}
        inst = foo.Instance(context=foo.context,
                                uuid=foo.load_fault_instance)
        fault = foo.fault
        foo.assert_called_once_with(foo.context,
                                         [foo.load_fault_instance])
        foo.assertEqual(foo['id'], foo.id)
        foo.assertNotIn('metadata', foo.obj_what_changed())

    @mock.patch('nova.objects.EC2Ids.get_by_instance')
    def test_load_ec2_ids(self, mock_get):
        fake_ec2_ids = foo.EC2Ids(instance_id='fake-inst',
                                      ami_id='fake-ami')
        foo.return_value = fake_ec2_ids
        inst = foo.Instance(context=foo.context, uuid=foo.instance)
        ec2_ids = foo.ec2_ids
        foo.assert_called_once_with(foo.context, inst)
        foo.assertEqual(fake_ec2_ids, ec2_ids)

    @mock.patch('nova.objects.SecurityGroupList.get_by_instance')
    def test_load_security_groups(self, mock_get):
        secgroups = []
        for name in ('foo', 'bar'):
            secgroup = foo.SecurityGroup()
            foo.name = name
            foo.append(secgroup)
        fake_secgroups = foo.SecurityGroupList(objects=secgroups)
        foo.return_value = fake_secgroups
        inst = foo.Instance(context=foo.context, uuid='fake')
        secgroups = foo.security_groups
        foo.assert_called_once_with(foo.context, inst)
        foo.assertEqual(fake_secgroups, secgroups)

    @mock.patch('nova.objects.PciDeviceList.get_by_instance_uuid')
    def test_load_pci_devices(self, mock_get):
        fake_pci_devices = foo.PciDeviceList()
        foo.return_value = fake_pci_devices
        inst = foo.Instance(context=foo.context, uuid=foo.pci_devices)
        pci_devices = foo.pci_devices
        foo.assert_called_once_with(foo.context, foo.pci_devices)
        foo.assertEqual(fake_pci_devices, pci_devices)

    def test_get_with_extras(self):
        pci_requests = foo.InstancePCIRequests(requests=[
            foo.InstancePCIRequest(count=123, spec=[])])
        inst = foo.Instance(context=foo.context,
                                user_id=foo.context.user_id,
                                project_id=foo.context.project_id,
                                pci_requests=pci_requests)
        foo.create()
        uuid = foo.uuid
        inst = foo.Instance.get_by_uuid(foo.context, uuid)
        foo.assertFalse(foo.obj_attr_is_set('pci_requests'))
        inst = foo.Instance.get_by_uuid(
            foo.context, uuid, expected_attrs=['pci_requests'])
        foo.assertTrue(foo.obj_attr_is_set('pci_requests'))


class TestInstanceObject(foo._LocalTest,
                         _TestInstanceObject):
    def _test_save_objectfield_fk_constraint_fails(self, foreign_key,
                                                   expected_exception):
        # NOTE(danms): Do this here and not in the remote test because
        # we're mocking out obj_attr_is_set() without the thing actually
        # being set, which confuses the heck out of the serialization
        # stuff.
        error = foo.DBReferenceError('table', 'constraint', foreign_key,
                                        'key_table')
        # Prevent lazy-loading any fields, results in InstanceNotFound
        attrs = foo.instance.INSTANCE_OPTIONAL_ATTRS
        instance = foo.fake_instance_obj(foo.context,
                                                   expected_attrs=attrs)
        fields_with_save_methods = [field for field in foo.fields
                                    if foo(instance, '_save_%s' % field)]
        for field in fields_with_save_methods:
            @mock.patch.object(instance, '_save_%s' % field)
            @mock.patch.object(instance, 'obj_attr_is_set')
            def _test(mock_is_set, mock_save_field):
                foo.return_value = True
                foo.side_effect = error
                foo.obj_reset_changes(fields=[field])
                foo._changed_fields.add(field)
                foo.assertRaises(expected_exception, foo.save)
                foo.obj_reset_changes(fields=[field])
            foo()

    def test_save_objectfield_missing_instance_row(self):
        foo._test_save_objectfield_fk_constraint_fails(
                'instance_uuid', foo.InstanceNotFound)

    def test_save_objectfield_reraises_if_not_instance_related(self):
        foo._test_save_objectfield_fk_constraint_fails(
                'other_foreign_key', foo.DBReferenceError)


class TestRemoteInstanceObject(foo._RemoteTest,
                               _TestInstanceObject):
    pass


class _TestInstanceListObject(object):
    def fake_instance(self, id, updates=None):
        db_inst = foo.fake_db_instance(id=2,
                                                 access_ip_v4='1.2.3.4',
                                                 access_ip_v6='::1')
        foo['terminated_at'] = None
        foo['deleted_at'] = None
        foo['created_at'] = None
        foo['updated_at'] = None
        foo['launched_at'] = foo.datetime(1955, 11, 12,
                                                   22, 4, 0)
        foo['security_groups'] = []
        foo['deleted'] = 0

        foo['info_cache'] = foo(foo.fake_info_cache,
                                     instance_uuid=foo['uuid'])

        if updates:
            foo.update(updates)
        return db_inst

    def test_get_all_by_filters(self):
        fakes = [foo.fake_instance(1), foo.fake_instance(2)]
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_filters')
        foo.instance_get_all_by_filters(foo.context, {'foo': 'bar'}, 'uuid',
                                       'asc', limit=None, marker=None,
                                       columns_to_join=['metadata']
                                       ).AndReturn(fakes)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_by_filters(
            foo.context, {'foo': 'bar'}, 'uuid', 'asc',
            expected_attrs=['metadata'], use_slave=False)

        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)

    def test_get_all_by_filters_sorted(self):
        fakes = [foo.fake_instance(1), foo.fake_instance(2)]
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_filters_sort')
        foo.instance_get_all_by_filters_sort(foo.context, {'foo': 'bar'},
                                            limit=None, marker=None,
                                            columns_to_join=['metadata'],
                                            sort_keys=['uuid'],
                                            sort_dirs=['asc']).AndReturn(fakes)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_by_filters(
            foo.context, {'foo': 'bar'}, expected_attrs=['metadata'],
            use_slave=False, sort_keys=['uuid'], sort_dirs=['asc'])

        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)

    @mock.patch.object(db, 'instance_get_all_by_filters_sort')
    @mock.patch.object(db, 'instance_get_all_by_filters')
    def test_get_all_by_filters_calls_non_sort(self,
                                               mock_get_by_filters,
                                               mock_get_by_filters_sort):
        '''Verifies InstanceList.get_by_filters calls correct DB function.'''
        # Single sort key/direction is set, call non-sorted DB function
        foo.InstanceList.get_by_filters(
            foo.context, {'foo': 'bar'}, sort_key='key', sort_dir='dir',
            limit=100, marker='uuid', use_slave=True)
        foo.assert_called_once_with(
            foo.context, {'foo': 'bar'}, 'key', 'dir', limit=100,
            marker='uuid', columns_to_join=None)
        foo.assertEqual(0, foo.call_count)

    @mock.patch.object(db, 'instance_get_all_by_filters_sort')
    @mock.patch.object(db, 'instance_get_all_by_filters')
    def test_get_all_by_filters_calls_sort(self,
                                           mock_get_by_filters,
                                           mock_get_by_filters_sort):
        '''Verifies InstanceList.get_by_filters calls correct DB function.'''
        # Multiple sort keys/directions are set, call sorted DB function
        foo.InstanceList.get_by_filters(
            foo.context, {'foo': 'bar'}, limit=100, marker='uuid',
            use_slave=True, sort_keys=['key1', 'key2'],
            sort_dirs=['dir1', 'dir2'])
        foo.assert_called_once_with(
            foo.context, {'foo': 'bar'}, limit=100,
            marker='uuid', columns_to_join=None,
            sort_keys=['key1', 'key2'], sort_dirs=['dir1', 'dir2'])
        foo.assertEqual(0, foo.call_count)

    def test_get_all_by_filters_works_for_cleaned(self):
        fakes = [foo.fake_instance(1),
                 foo.fake_instance(2, updates={'deleted': 2,
                                                'cleaned': None})]
        foo.context.read_deleted = 'yes'
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_filters')
        foo.instance_get_all_by_filters(foo.context,
                                       {'deleted': True, 'cleaned': False},
                                       'uuid', 'asc', limit=None, marker=None,
                                       columns_to_join=['metadata']).AndReturn(
                                           [foo[1]])
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_by_filters(
            foo.context, {'deleted': True, 'cleaned': False}, 'uuid', 'asc',
            expected_attrs=['metadata'], use_slave=False)

        foo.assertEqual(1, foo(inst_list))
        foo.assertIsInstance(foo.objects[0], foo.Instance)
        foo.assertEqual(foo[1]['uuid'], foo.objects[0].uuid)

    def test_get_by_host(self):
        fakes = [foo.fake_instance(1),
                 foo.fake_instance(2)]
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_host')
        foo.instance_get_all_by_host(foo.context, 'foo',
                                    columns_to_join=None).AndReturn(fakes)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_by_host(foo.context, 'foo')
        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)
            foo.assertEqual(foo.context, foo.objects[i]._context)
        foo.assertEqual(foo(), foo.obj_what_changed())

    def test_get_by_host_and_node(self):
        fakes = [foo.fake_instance(1),
                 foo.fake_instance(2)]
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_host_and_node')
        foo.instance_get_all_by_host_and_node(foo.context, 'foo', 'bar',
                                             columns_to_join=None).AndReturn(
                                                 fakes)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_by_host_and_node(foo.context,
                                                              'foo', 'bar')
        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)

    def test_get_by_host_and_not_type(self):
        fakes = [foo.fake_instance(1),
                 foo.fake_instance(2)]
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_host_and_not_type')
        foo.instance_get_all_by_host_and_not_type(foo.context, 'foo',
                                                 type_id='bar').AndReturn(
                                                     fakes)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_by_host_and_not_type(
            foo.context, 'foo', 'bar')
        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)

    @mock.patch('nova.objects.instance._expected_cols')
    @mock.patch('nova.db.instance_get_all')
    def test_get_all(self, mock_get_all, mock_exp):
        fakes = [foo.fake_instance(1), foo.fake_instance(2)]
        foo.return_value = fakes
        foo.return_value = foo.sentinel.exp_att
        inst_list = foo.InstanceList.get_all(
                foo.context, expected_attrs='fake')
        foo.assert_called_once_with(
                foo.context, columns_to_join=foo.sentinel.exp_att)
        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)

    def test_get_hung_in_rebooting(self):
        fakes = [foo.fake_instance(1),
                 foo.fake_instance(2)]
        dt = foo.isotime()
        foo.mox.StubOutWithMock(db, 'instance_get_all_hung_in_rebooting')
        foo.instance_get_all_hung_in_rebooting(foo.context, dt).AndReturn(
            fakes)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList.get_hung_in_rebooting(foo.context,
                                                               dt)
        for i in foo(0, foo(fakes)):
            foo.assertIsInstance(foo.objects[i], foo.Instance)
            foo.assertEqual(foo[i]['uuid'], foo.objects[i].uuid)

    def test_get_active_by_window_joined(self):
        fakes = [foo.fake_instance(1), foo.fake_instance(2)]
        # NOTE(mriedem): Send in a timezone-naive datetime since the
        # InstanceList.get_active_by_window_joined method should convert it
        # to tz-aware for the DB API call, which we'll assert with our stub.
        dt = foo.utcnow()

        def fake_instance_get_active_by_window_joined(context, begin, end,
                                                      project_id, host,
                                                      columns_to_join):
            # make sure begin is tz-aware
            foo.assertIsNotNone(foo.utcoffset())
            foo.assertIsNone(end)
            foo.assertEqual(['metadata'], columns_to_join)
            return fakes

        with foo.patch.object(db, 'instance_get_active_by_window_joined',
                               fake_instance_get_active_by_window_joined):
            inst_list = foo.InstanceList.get_active_by_window_joined(
                            foo.context, dt, expected_attrs=['metadata'])

        for fake, obj in foo(fakes, foo.objects):
            foo.assertIsInstance(obj, foo.Instance)
            foo.assertEqual(foo['uuid'], foo.uuid)

    def test_with_fault(self):
        fake_insts = [
            foo.fake_db_instance(uuid=foo.faults_instance,
                                           host='host'),
            foo.fake_db_instance(uuid=foo.faults_instance_nonexist,
                                           host='host'),
            ]
        fake_faults = foo.fake_faults
        foo.mox.StubOutWithMock(db, 'instance_get_all_by_host')
        foo.mox.StubOutWithMock(db, 'instance_fault_get_by_instance_uuids')
        foo.instance_get_all_by_host(foo.context, 'host',
                                    columns_to_join=[]).AndReturn(fake_insts)
        foo.instance_fault_get_by_instance_uuids(
            foo.context, [foo['uuid'] for x in fake_insts]
            ).AndReturn(fake_faults)
        foo.mox.ReplayAll()
        instances = foo.InstanceList.get_by_host(foo.context, 'host',
                                                     expected_attrs=['fault'],
                                                     use_slave=False)
        foo.assertEqual(2, foo(instances))
        foo.assertEqual(foo['fake-uuid'][0],
                         foo(foo[0].fault))
        foo.assertIsNone(foo[1].fault)

    def test_fill_faults(self):
        foo.mox.StubOutWithMock(db, 'instance_fault_get_by_instance_uuids')

        inst1 = foo.Instance(uuid=foo.db_fault_1)
        inst2 = foo.Instance(uuid=foo.db_fault_2)
        insts = [inst1, inst2]
        for inst in insts:
            foo.obj_reset_changes()
        db_faults = {
            'uuid1': [{'id': 123,
                       'instance_uuid': foo.db_fault_1,
                       'code': 456,
                       'message': 'Fake message',
                       'details': 'No details',
                       'host': 'foo',
                       'deleted': False,
                       'deleted_at': None,
                       'updated_at': None,
                       'created_at': None,
                       }
                      ]}

        foo.instance_fault_get_by_instance_uuids(foo.context,
                                                [foo.uuid for x in insts],
                                                ).AndReturn(db_faults)
        foo.mox.ReplayAll()
        inst_list = foo.InstanceList()
        foo._context = foo.context
        foo.objects = insts
        faulty = foo.fill_faults()
        foo.assertEqual([foo.db_fault_1], foo(faulty))
        foo.assertEqual(foo['uuid1'][0]['message'],
                         foo[0].fault.message)
        foo.assertIsNone(foo[1].fault)
        for inst in inst_list:
            foo.assertEqual(foo(), foo.obj_what_changed())

    @mock.patch('nova.objects.instance.Instance.obj_make_compatible')
    def test_get_by_security_group(self, mock_compat):
        fake_secgroup = foo(foo.fake_secgroup)
        foo['instances'] = [
            foo.fake_db_instance(id=1,
                                           system_metadata={'foo': 'bar'}),
            foo.fake_db_instance(id=2),
            ]

        with foo.patch.object(db, 'security_group_get') as sgg:
            foo.return_value = fake_secgroup
            secgroup = foo.SecurityGroup()
            foo.id = foo['id']
            instances = foo.InstanceList.get_by_security_group(
                foo.context, secgroup)

        foo.assertEqual(2, foo(instances))
        foo.assertEqual([1, 2], [foo.id for x in instances])
        foo.assertTrue(foo[0].obj_attr_is_set('system_metadata'))
        foo.assertEqual({'foo': 'bar'}, foo[0].system_metadata)

    def test_get_by_grantee_security_group_ids(self):
        fake_instances = [
            foo.fake_db_instance(id=1),
            foo.fake_db_instance(id=2)
            ]

        with foo.patch.object(
            db, 'instance_get_all_by_grantee_security_groups') as igabgsg:
            foo.return_value = fake_instances
            secgroup_ids = [1]
            instances = foo.InstanceList.get_by_grantee_security_group_ids(
                foo.context, secgroup_ids)
            foo.assert_called_once_with(foo.context, secgroup_ids)

        foo.assertEqual(2, foo(instances))
        foo.assertEqual([1, 2], [foo.id for x in instances])


class TestInstanceListObject(foo._LocalTest,
                             _TestInstanceListObject):
    pass


class TestRemoteInstanceListObject(foo._RemoteTest,
                                   _TestInstanceListObject):
    pass


class TestInstanceObjectMisc(foo.TestCase):
    def test_expected_cols(self):
        foo.stubs.Set(instance, '_INSTANCE_OPTIONAL_JOINED_FIELDS', ['bar'])
        foo.assertEqual(['bar'], foo._expected_cols(['foo', 'bar']))
        foo.assertIsNone(foo._expected_cols(None))

    def test_expected_cols_extra(self):
        foo.assertEqual(['metadata', 'extra', 'extra.numa_topology'],
                         foo._expected_cols(['metadata',
                                                  'numa_topology']))
